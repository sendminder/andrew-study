# gRPC 에러 처리 및 모니터링 완벽 가이드

## 에러 처리 개요

gRPC는 구조화된 에러 처리 시스템을 제공합니다. 표준 상태 코드와 상세한 에러 정보를 통해 체계적인 에러 처리가 가능합니다.

## 1. gRPC 상태 코드

### 표준 상태 코드

| 코드 | 이름 | 설명 | HTTP 매핑 |
|------|------|------|-----------|
| 0 | OK | 성공 | 200 |
| 1 | CANCELLED | 작업 취소 | 499 |
| 2 | UNKNOWN | 알 수 없는 에러 | 500 |
| 3 | INVALID_ARGUMENT | 잘못된 인자 | 400 |
| 4 | DEADLINE_EXCEEDED | 타임아웃 | 504 |
| 5 | NOT_FOUND | 리소스 없음 | 404 |
| 6 | ALREADY_EXISTS | 이미 존재 | 409 |
| 7 | PERMISSION_DENIED | 권한 없음 | 403 |
| 8 | RESOURCE_EXHAUSTED | 리소스 고갈 | 429 |
| 9 | FAILED_PRECONDITION | 사전 조건 실패 | 400 |
| 10 | ABORTED | 작업 중단 | 409 |
| 11 | OUT_OF_RANGE | 범위 초과 | 400 |
| 12 | UNIMPLEMENTED | 구현되지 않음 | 501 |
| 13 | INTERNAL | 내부 에러 | 500 |
| 14 | UNAVAILABLE | 서비스 불가 | 503 |
| 15 | DATA_LOSS | 데이터 손실 | 500 |
| 16 | UNAUTHENTICATED | 인증 필요 | 401 |

## 2. 서버 에러 처리

### 기본 에러 반환

```go
// errors/server_errors.go
package errors

import (
    "context"
    "fmt"
    
    pb "myapp/pb"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

type UserService struct {
    pb.UnimplementedUserServiceServer
    users map[int32]*pb.User
}

// 기본 에러 처리
func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    // 입력 검증
    if req.Id <= 0 {
        return nil, status.Errorf(codes.InvalidArgument, 
            "잘못된 사용자 ID: %d", req.Id)
    }
    
    // 리소스 확인
    user, exists := s.users[req.Id]
    if !exists {
        return nil, status.Errorf(codes.NotFound, 
            "사용자를 찾을 수 없습니다: ID=%d", req.Id)
    }
    
    // 권한 확인
    if !hasPermission(ctx, user) {
        return nil, status.Error(codes.PermissionDenied, 
            "사용자 정보 접근 권한이 없습니다")
    }
    
    return user, nil
}

// 타임아웃 처리
func (s *UserService) ProcessData(ctx context.Context, req *pb.ProcessRequest) (*pb.ProcessResponse, error) {
    // 컨텍스트 확인
    select {
    case <-ctx.Done():
        return nil, status.Error(codes.DeadlineExceeded, 
            "처리 시간 초과")
    default:
    }
    
    // 처리 로직
    if err := processLongRunningTask(ctx); err != nil {
        return nil, status.Error(codes.Internal, 
            "데이터 처리 실패")
    }
    
    return &pb.ProcessResponse{Success: true}, nil
}
```

### 상세 에러 정보

```go
// errors/detailed_errors.go
package errors

import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "google.golang.org/genproto/googleapis/rpc/errdetails"
)

// 상세 에러 정보 포함
func CreateDetailedError() error {
    st := status.New(codes.InvalidArgument, "입력 검증 실패")
    
    // BadRequest 상세 정보
    br := &errdetails.BadRequest{}
    br.FieldViolations = append(br.FieldViolations,
        &errdetails.BadRequest_FieldViolation{
            Field:       "email",
            Description: "유효하지 않은 이메일 형식",
        },
        &errdetails.BadRequest_FieldViolation{
            Field:       "age",
            Description: "나이는 0보다 커야 합니다",
        },
    )
    
    // 에러 정보 추가
    st, err := st.WithDetails(br)
    if err != nil {
        return status.Error(codes.InvalidArgument, "입력 검증 실패")
    }
    
    return st.Err()
}

// 재시도 정보 포함
func CreateRetryableError() error {
    st := status.New(codes.ResourceExhausted, "요청 한도 초과")
    
    // RetryInfo 추가
    ri := &errdetails.RetryInfo{
        RetryDelay: &duration.Duration{
            Seconds: 30,
        },
    }
    
    st, _ = st.WithDetails(ri)
    return st.Err()
}

// 디버그 정보 포함
func CreateDebugError(requestID string, stackTrace string) error {
    st := status.New(codes.Internal, "내부 서버 오류")
    
    // DebugInfo 추가
    di := &errdetails.DebugInfo{
        StackEntries: []string{stackTrace},
        Detail:       fmt.Sprintf("request_id: %s", requestID),
    }
    
    st, _ = st.WithDetails(di)
    return st.Err()
}

// 할당량 위반 에러
func CreateQuotaError() error {
    st := status.New(codes.ResourceExhausted, "할당량 초과")
    
    // QuotaFailure 추가
    qf := &errdetails.QuotaFailure{
        Violations: []*errdetails.QuotaFailure_Violation{
            {
                Subject:     "user:123",
                Description: "일일 API 호출 한도 초과",
            },
        },
    }
    
    st, _ = st.WithDetails(qf)
    return st.Err()
}
```

### 커스텀 에러 타입

```go
// errors/custom_errors.go
package errors

import (
    "fmt"
    
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// 비즈니스 에러 타입
type BusinessError struct {
    Code    string
    Message string
    Details map[string]interface{}
}

func (e *BusinessError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *BusinessError) GRPCStatus() *status.Status {
    // 비즈니스 에러를 gRPC 상태로 변환
    code := codes.Internal
    switch e.Code {
    case "USER_NOT_FOUND":
        code = codes.NotFound
    case "INVALID_INPUT":
        code = codes.InvalidArgument
    case "UNAUTHORIZED":
        code = codes.Unauthenticated
    case "FORBIDDEN":
        code = codes.PermissionDenied
    }
    
    return status.New(code, e.Message)
}

// 에러 빌더
type ErrorBuilder struct {
    code    codes.Code
    message string
    details []interface{}
}

func NewError(code codes.Code, message string) *ErrorBuilder {
    return &ErrorBuilder{
        code:    code,
        message: message,
    }
}

func (b *ErrorBuilder) WithDetail(detail interface{}) *ErrorBuilder {
    b.details = append(b.details, detail)
    return b
}

func (b *ErrorBuilder) Build() error {
    st := status.New(b.code, b.message)
    if len(b.details) > 0 {
        st, _ = st.WithDetails(b.details...)
    }
    return st.Err()
}
```

## 3. 클라이언트 에러 처리

### 에러 처리 패턴

```go
// errors/client_errors.go
package errors

import (
    "context"
    "log"
    "time"
    
    pb "myapp/pb"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "google.golang.org/genproto/googleapis/rpc/errdetails"
)

// 기본 에러 처리
func HandleBasicError(client pb.UserServiceClient) {
    ctx := context.Background()
    
    user, err := client.GetUser(ctx, &pb.GetUserRequest{Id: 1})
    if err != nil {
        st, ok := status.FromError(err)
        if !ok {
            log.Printf("알 수 없는 에러: %v", err)
            return
        }
        
        log.Printf("RPC 실패: Code=%s, Message=%s", 
            st.Code(), st.Message())
        
        // 에러 코드별 처리
        switch st.Code() {
        case codes.NotFound:
            log.Println("사용자를 찾을 수 없음 - 새 사용자 생성")
            createNewUser(client)
            
        case codes.InvalidArgument:
            log.Println("잘못된 요청 - 입력 확인 필요")
            
        case codes.DeadlineExceeded:
            log.Println("타임아웃 - 재시도")
            retryWithBackoff(client)
            
        case codes.Unauthenticated:
            log.Println("인증 필요 - 로그인 수행")
            performLogin()
            
        default:
            log.Printf("처리되지 않은 에러: %v", st.Code())
        }
        
        return
    }
    
    log.Printf("사용자 조회 성공: %+v", user)
}

// 상세 에러 정보 처리
func HandleDetailedError(client pb.UserServiceClient) {
    ctx := context.Background()
    
    _, err := client.CreateUser(ctx, &pb.CreateUserRequest{
        Email: "invalid-email",
        Age:   -1,
    })
    
    if err != nil {
        st := status.Convert(err)
        
        for _, detail := range st.Details() {
            switch t := detail.(type) {
            case *errdetails.BadRequest:
                log.Println("입력 검증 실패:")
                for _, violation := range t.GetFieldViolations() {
                    log.Printf("  - %s: %s", 
                        violation.GetField(), 
                        violation.GetDescription())
                }
                
            case *errdetails.RetryInfo:
                retryDelay := t.GetRetryDelay().Seconds
                log.Printf("재시도 필요: %d초 후", retryDelay)
                time.Sleep(time.Duration(retryDelay) * time.Second)
                
            case *errdetails.DebugInfo:
                log.Printf("디버그 정보: %s", t.GetDetail())
                
            case *errdetails.QuotaFailure:
                for _, violation := range t.GetViolations() {
                    log.Printf("할당량 초과: %s - %s",
                        violation.GetSubject(),
                        violation.GetDescription())
                }
            }
        }
    }
}

// 재시도 로직
func retryWithBackoff(client pb.UserServiceClient) {
    maxRetries := 3
    backoff := time.Second
    
    for i := 0; i < maxRetries; i++ {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        user, err := client.GetUser(ctx, &pb.GetUserRequest{Id: 1})
        
        if err == nil {
            log.Printf("재시도 성공: %+v", user)
            return
        }
        
        st, _ := status.FromError(err)
        if !isRetryable(st.Code()) {
            log.Printf("재시도 불가능한 에러: %v", st.Code())
            return
        }
        
        log.Printf("재시도 %d/%d, 대기: %v", i+1, maxRetries, backoff)
        time.Sleep(backoff)
        backoff *= 2 // 지수 백오프
    }
    
    log.Println("최대 재시도 횟수 초과")
}

func isRetryable(code codes.Code) bool {
    switch code {
    case codes.Unavailable, codes.DeadlineExceeded, codes.ResourceExhausted:
        return true
    default:
        return false
    }
}
```

## 4. 모니터링 구현

### Prometheus 메트릭

```go
// monitoring/prometheus.go
package monitoring

import (
    "context"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "google.golang.org/grpc"
    "google.golang.org/grpc/status"
)

var (
    // RPC 요청 카운터
    rpcRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "grpc_requests_total",
            Help: "Total number of gRPC requests",
        },
        []string{"method", "status"},
    )
    
    // RPC 지연 시간
    rpcDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "grpc_request_duration_seconds",
            Help:    "gRPC request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method"},
    )
    
    // 활성 연결 수
    activeConnections = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "grpc_active_connections",
            Help: "Number of active gRPC connections",
        },
    )
    
    // 에러 카운터
    rpcErrors = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "grpc_errors_total",
            Help: "Total number of gRPC errors",
        },
        []string{"method", "code"},
    )
)

// PrometheusInterceptor - 메트릭 수집 인터셉터
func PrometheusInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        // 핸들러 실행
        resp, err := handler(ctx, req)
        
        // 메트릭 기록
        duration := time.Since(start).Seconds()
        rpcDuration.WithLabelValues(info.FullMethod).Observe(duration)
        
        statusCode := "OK"
        if err != nil {
            st, _ := status.FromError(err)
            statusCode = st.Code().String()
            rpcErrors.WithLabelValues(info.FullMethod, statusCode).Inc()
        }
        
        rpcRequestsTotal.WithLabelValues(info.FullMethod, statusCode).Inc()
        
        return resp, err
    }
}

// 연결 모니터링
func MonitorConnections() {
    // 연결 수 증가
    activeConnections.Inc()
    
    // 연결 종료시 감소
    defer activeConnections.Dec()
}
```

### OpenTelemetry 통합

```go
// monitoring/opentelemetry.go
package monitoring

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

// Tracer 초기화
func InitTracer(serviceName string) (*sdktrace.TracerProvider, error) {
    // Jaeger exporter 생성
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint())
    if err != nil {
        return nil, err
    }
    
    // TracerProvider 생성
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exp),
        sdktrace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceNameKey.String(serviceName),
        )),
    )
    
    otel.SetTracerProvider(tp)
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))
    
    return tp, nil
}

// TracingInterceptor - 분산 추적 인터셉터
func TracingInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 트레이서 가져오기
        tracer := otel.Tracer("grpc-server")
        
        // 메타데이터에서 trace context 추출
        md, _ := metadata.FromIncomingContext(ctx)
        ctx = otel.GetTextMapPropagator().Extract(ctx, 
            metadataCarrier(md))
        
        // 스팬 시작
        ctx, span := tracer.Start(ctx, info.FullMethod,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
                attribute.String("rpc.service", "UserService"),
            ),
        )
        defer span.End()
        
        // 핸들러 실행
        resp, err := handler(ctx, req)
        
        // 에러 기록
        if err != nil {
            span.RecordError(err)
            span.SetAttributes(attribute.Bool("error", true))
        }
        
        return resp, err
    }
}

// 메타데이터 carrier
type metadataCarrier metadata.MD

func (m metadataCarrier) Get(key string) string {
    vals := metadata.MD(m).Get(key)
    if len(vals) > 0 {
        return vals[0]
    }
    return ""
}

func (m metadataCarrier) Set(key string, value string) {
    metadata.MD(m).Set(key, value)
}

func (m metadataCarrier) Keys() []string {
    keys := make([]string, 0, len(m))
    for k := range metadata.MD(m) {
        keys = append(keys, k)
    }
    return keys
}
```

### 로깅 구현

```go
// monitoring/logging.go
package monitoring

import (
    "context"
    "time"
    
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/peer"
    "google.golang.org/grpc/status"
)

// 구조화된 로거 생성
func NewLogger() (*zap.Logger, error) {
    config := zap.NewProductionConfig()
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    return config.Build()
}

// StructuredLoggingInterceptor - 구조화된 로깅
func StructuredLoggingInterceptor(logger *zap.Logger) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        // 요청 정보 추출
        md, _ := metadata.FromIncomingContext(ctx)
        p, _ := peer.FromContext(ctx)
        
        // 요청 로깅
        requestLogger := logger.With(
            zap.String("method", info.FullMethod),
            zap.String("peer", p.Addr.String()),
            zap.Any("metadata", md),
            zap.String("request_id", getRequestID(md)),
        )
        
        requestLogger.Info("gRPC request started")
        
        // 핸들러 실행
        resp, err := handler(ctx, req)
        
        // 응답 로깅
        duration := time.Since(start)
        
        fields := []zap.Field{
            zap.Duration("duration", duration),
        }
        
        if err != nil {
            st, _ := status.FromError(err)
            fields = append(fields,
                zap.String("error_code", st.Code().String()),
                zap.String("error_message", st.Message()),
                zap.Error(err),
            )
            requestLogger.Error("gRPC request failed", fields...)
        } else {
            requestLogger.Info("gRPC request completed", fields...)
        }
        
        return resp, err
    }
}

// 액세스 로그
func AccessLogInterceptor(logger *zap.Logger) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        resp, err := handler(ctx, req)
        
        // 액세스 로그 포맷
        p, _ := peer.FromContext(ctx)
        statusCode := "OK"
        if err != nil {
            st, _ := status.FromError(err)
            statusCode = st.Code().String()
        }
        
        logger.Info("access",
            zap.String("remote_addr", p.Addr.String()),
            zap.String("method", info.FullMethod),
            zap.String("status", statusCode),
            zap.Duration("latency", time.Since(start)),
            zap.Time("time", start),
        )
        
        return resp, err
    }
}
```

### 헬스 체크

```go
// monitoring/health.go
package monitoring

import (
    "context"
    "sync"
    
    "google.golang.org/grpc/health"
    "google.golang.org/grpc/health/grpc_health_v1"
)

type HealthChecker struct {
    mu       sync.RWMutex
    services map[string]grpc_health_v1.HealthCheckResponse_ServingStatus
    server   *health.Server
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        services: make(map[string]grpc_health_v1.HealthCheckResponse_ServingStatus),
        server:   health.NewServer(),
    }
}

// 서비스 상태 설정
func (h *HealthChecker) SetServiceStatus(service string, status grpc_health_v1.HealthCheckResponse_ServingStatus) {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    h.services[service] = status
    h.server.SetServingStatus(service, status)
}

// 헬스 체크 구현
func (h *HealthChecker) Check(ctx context.Context, req *grpc_health_v1.HealthCheckRequest) (*grpc_health_v1.HealthCheckResponse, error) {
    h.mu.RLock()
    defer h.mu.RUnlock()
    
    // 특정 서비스 체크
    if req.Service != "" {
        status, exists := h.services[req.Service]
        if !exists {
            return &grpc_health_v1.HealthCheckResponse{
                Status: grpc_health_v1.HealthCheckResponse_SERVICE_UNKNOWN,
            }, nil
        }
        
        return &grpc_health_v1.HealthCheckResponse{
            Status: status,
        }, nil
    }
    
    // 전체 서비스 체크
    for _, status := range h.services {
        if status != grpc_health_v1.HealthCheckResponse_SERVING {
            return &grpc_health_v1.HealthCheckResponse{
                Status: grpc_health_v1.HealthCheckResponse_NOT_SERVING,
            }, nil
        }
    }
    
    return &grpc_health_v1.HealthCheckResponse{
        Status: grpc_health_v1.HealthCheckResponse_SERVING,
    }, nil
}

// Watch 구현 (스트리밍 헬스 체크)
func (h *HealthChecker) Watch(req *grpc_health_v1.HealthCheckRequest, stream grpc_health_v1.Health_WatchServer) error {
    // 초기 상태 전송
    resp, _ := h.Check(stream.Context(), req)
    if err := stream.Send(resp); err != nil {
        return err
    }
    
    // 상태 변경 감지 및 전송
    // (실제 구현에서는 채널을 사용하여 상태 변경 알림)
    <-stream.Context().Done()
    return nil
}
```

## 5. 대시보드 구성

### Grafana 대시보드 예제

```json
{
  "dashboard": {
    "title": "gRPC Monitoring",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(grpc_requests_total[5m])"
          }
        ]
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(grpc_errors_total[5m])"
          }
        ]
      },
      {
        "title": "P95 Latency",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(grpc_request_duration_seconds_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Active Connections",
        "targets": [
          {
            "expr": "grpc_active_connections"
          }
        ]
      }
    ]
  }
}
```

## 6. 통합 예제

```go
// main.go
package main

import (
    "log"
    "net"
    "net/http"
    
    pb "myapp/pb"
    "myapp/monitoring"
    
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "go.uber.org/zap"
    "google.golang.org/grpc"
    "google.golang.org/grpc/health/grpc_health_v1"
)

func main() {
    // 로거 초기화
    logger, err := monitoring.NewLogger()
    if err != nil {
        log.Fatal(err)
    }
    defer logger.Sync()
    
    // 트레이서 초기화
    tp, err := monitoring.InitTracer("grpc-server")
    if err != nil {
        logger.Fatal("트레이서 초기화 실패", zap.Error(err))
    }
    defer tp.Shutdown(context.Background())
    
    // 헬스 체커 생성
    healthChecker := monitoring.NewHealthChecker()
    
    // gRPC 서버 생성 (모니터링 인터셉터 포함)
    server := grpc.NewServer(
        grpc.ChainUnaryInterceptor(
            monitoring.StructuredLoggingInterceptor(logger),
            monitoring.PrometheusInterceptor(),
            monitoring.TracingInterceptor(),
            monitoring.AccessLogInterceptor(logger),
        ),
    )
    
    // 서비스 등록
    userService := NewUserService()
    pb.RegisterUserServiceServer(server, userService)
    
    // 헬스 체크 등록
    grpc_health_v1.RegisterHealthServer(server, healthChecker)
    healthChecker.SetServiceStatus("UserService", 
        grpc_health_v1.HealthCheckResponse_SERVING)
    
    // Prometheus 메트릭 엔드포인트
    go func() {
        http.Handle("/metrics", promhttp.Handler())
        logger.Info("메트릭 서버 시작", zap.String("addr", ":9090"))
        if err := http.ListenAndServe(":9090", nil); err != nil {
            logger.Error("메트릭 서버 실패", zap.Error(err))
        }
    }()
    
    // gRPC 서버 시작
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        logger.Fatal("리스너 생성 실패", zap.Error(err))
    }
    
    logger.Info("gRPC 서버 시작", 
        zap.String("addr", ":50051"),
        zap.Bool("monitoring", true),
    )
    
    if err := server.Serve(lis); err != nil {
        logger.Fatal("서버 실행 실패", zap.Error(err))
    }
}
```

## Best Practices

1. **적절한 에러 코드**: 상황에 맞는 gRPC 상태 코드 사용
2. **상세 정보 제공**: 디버깅을 위한 충분한 에러 정보
3. **구조화된 로깅**: JSON 형식의 구조화된 로그
4. **메트릭 수집**: RED (Rate, Errors, Duration) 메트릭
5. **분산 추적**: 마이크로서비스 환경에서 요청 추적
6. **헬스 체크**: 서비스 상태 모니터링
7. **알림 설정**: 임계값 기반 알림

## 다음 단계

에러 처리와 모니터링을 마스터했다면:
1. 성능 최적화
2. 보안 강화
3. 프로덕션 배포
4. 스케일링 전략

## 참고 자료

- [gRPC Error Handling](https://grpc.io/docs/guides/error/)
- [gRPC Health Checking](https://github.com/grpc/grpc/blob/master/doc/health-checking.md)
- [OpenTelemetry Go](https://opentelemetry.io/docs/instrumentation/go/)
- [Prometheus Go Client](https://github.com/prometheus/client_golang)