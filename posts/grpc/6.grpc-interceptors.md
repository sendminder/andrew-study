# gRPC 인터셉터와 미들웨어 완벽 가이드

## 인터셉터 개요

gRPC 인터셉터는 RPC 호출을 가로채서 추가 기능을 구현할 수 있는 강력한 메커니즘입니다. 인증, 로깅, 모니터링, 재시도 등의 횡단 관심사(cross-cutting concerns)를 처리하는데 사용됩니다.

## 인터셉터 종류

| 구분 | Unary Interceptor | Stream Interceptor |
|------|------------------|-------------------|
| **서버** | UnaryServerInterceptor | StreamServerInterceptor |
| **클라이언트** | UnaryClientInterceptor | StreamClientInterceptor |
| **용도** | 단일 요청-응답 | 스트리밍 RPC |

## 1. 서버 인터셉터

### Unary Server Interceptor

```go
// interceptors/server_interceptors.go
package interceptors

import (
    "context"
    "log"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/status"
)

// LoggingInterceptor - 요청/응답 로깅
func LoggingInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        // 메타데이터 추출
        md, _ := metadata.FromIncomingContext(ctx)
        requestID := getRequestID(md)
        
        log.Printf("[%s] gRPC 요청 시작: %s", requestID, info.FullMethod)
        
        // 다음 핸들러 호출
        resp, err := handler(ctx, req)
        
        // 응답 로깅
        duration := time.Since(start)
        statusCode := codes.OK
        if err != nil {
            statusCode = status.Code(err)
        }
        
        log.Printf("[%s] gRPC 요청 완료: %s, Status: %s, Duration: %v",
            requestID, info.FullMethod, statusCode, duration)
        
        return resp, err
    }
}

// AuthenticationInterceptor - 인증 처리
func AuthenticationInterceptor(authFunc func(context.Context) error) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 인증이 필요없는 메서드 체크
        if isPublicMethod(info.FullMethod) {
            return handler(ctx, req)
        }
        
        // 토큰 검증
        if err := authFunc(ctx); err != nil {
            return nil, status.Errorf(codes.Unauthenticated, "인증 실패: %v", err)
        }
        
        return handler(ctx, req)
    }
}

// RateLimitInterceptor - 요청 속도 제한
func RateLimitInterceptor(limiter RateLimiter) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 클라이언트 식별
        clientID := getClientID(ctx)
        
        // 속도 제한 체크
        if !limiter.Allow(clientID) {
            return nil, status.Errorf(codes.ResourceExhausted, 
                "요청 속도 제한 초과")
        }
        
        return handler(ctx, req)
    }
}

// RecoveryInterceptor - 패닉 복구
func RecoveryInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (resp interface{}, err error) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("패닉 복구: %v", r)
                err = status.Errorf(codes.Internal, "내부 서버 오류")
            }
        }()
        
        return handler(ctx, req)
    }
}

// ValidationInterceptor - 입력 검증
func ValidationInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 검증 가능한 타입인지 확인
        if validator, ok := req.(interface{ Validate() error }); ok {
            if err := validator.Validate(); err != nil {
                return nil, status.Errorf(codes.InvalidArgument, 
                    "입력 검증 실패: %v", err)
            }
        }
        
        return handler(ctx, req)
    }
}

// MetricsInterceptor - 메트릭 수집
func MetricsInterceptor(collector MetricsCollector) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        // 요청 카운터 증가
        collector.IncrementRequestCount(info.FullMethod)
        
        // 핸들러 실행
        resp, err := handler(ctx, req)
        
        // 응답 시간 기록
        duration := time.Since(start)
        collector.RecordLatency(info.FullMethod, duration)
        
        // 에러 카운터
        if err != nil {
            collector.IncrementErrorCount(info.FullMethod)
        }
        
        return resp, err
    }
}
```

### Stream Server Interceptor

```go
// interceptors/stream_server_interceptors.go
package interceptors

import (
    "context"
    "io"
    "log"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// StreamLoggingInterceptor - 스트림 로깅
func StreamLoggingInterceptor() grpc.StreamServerInterceptor {
    return func(
        srv interface{},
        ss grpc.ServerStream,
        info *grpc.StreamServerInfo,
        handler grpc.StreamHandler,
    ) error {
        start := time.Now()
        
        log.Printf("스트림 시작: %s, IsClientStream: %v, IsServerStream: %v",
            info.FullMethod, info.IsClientStream, info.IsServerStream)
        
        // 래퍼 스트림 생성
        wrapped := &loggingServerStream{
            ServerStream: ss,
            method:       info.FullMethod,
        }
        
        // 핸들러 실행
        err := handler(srv, wrapped)
        
        duration := time.Since(start)
        log.Printf("스트림 종료: %s, Duration: %v, Error: %v",
            info.FullMethod, duration, err)
        
        return err
    }
}

// loggingServerStream - 스트림 래퍼
type loggingServerStream struct {
    grpc.ServerStream
    method string
}

func (s *loggingServerStream) SendMsg(m interface{}) error {
    log.Printf("[%s] 메시지 전송: %T", s.method, m)
    return s.ServerStream.SendMsg(m)
}

func (s *loggingServerStream) RecvMsg(m interface{}) error {
    err := s.ServerStream.RecvMsg(m)
    if err == nil {
        log.Printf("[%s] 메시지 수신: %T", s.method, m)
    } else if err != io.EOF {
        log.Printf("[%s] 수신 에러: %v", s.method, err)
    }
    return err
}

// StreamAuthInterceptor - 스트림 인증
func StreamAuthInterceptor(authFunc func(context.Context) error) grpc.StreamServerInterceptor {
    return func(
        srv interface{},
        ss grpc.ServerStream,
        info *grpc.StreamServerInfo,
        handler grpc.StreamHandler,
    ) error {
        if err := authFunc(ss.Context()); err != nil {
            return status.Errorf(codes.Unauthenticated, "인증 실패: %v", err)
        }
        
        return handler(srv, ss)
    }
}

// StreamRecoveryInterceptor - 스트림 패닉 복구
func StreamRecoveryInterceptor() grpc.StreamServerInterceptor {
    return func(
        srv interface{},
        ss grpc.ServerStream,
        info *grpc.StreamServerInfo,
        handler grpc.StreamHandler,
    ) (err error) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("스트림 패닉 복구: %v", r)
                err = status.Errorf(codes.Internal, "스트림 내부 오류")
            }
        }()
        
        return handler(srv, ss)
    }
}
```

## 2. 클라이언트 인터셉터

### Unary Client Interceptor

```go
// interceptors/client_interceptors.go
package interceptors

import (
    "context"
    "log"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/status"
)

// ClientLoggingInterceptor - 클라이언트 로깅
func ClientLoggingInterceptor() grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        start := time.Now()
        
        log.Printf("RPC 호출 시작: %s", method)
        
        // RPC 호출
        err := invoker(ctx, method, req, reply, cc, opts...)
        
        duration := time.Since(start)
        if err != nil {
            log.Printf("RPC 호출 실패: %s, Duration: %v, Error: %v",
                method, duration, err)
        } else {
            log.Printf("RPC 호출 성공: %s, Duration: %v",
                method, duration)
        }
        
        return err
    }
}

// RetryInterceptor - 재시도 인터셉터
func RetryInterceptor(maxRetries int) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        var lastErr error
        
        for i := 0; i <= maxRetries; i++ {
            if i > 0 {
                // 지수 백오프
                backoff := time.Duration(i) * time.Second
                log.Printf("재시도 %d/%d: %s (대기: %v)",
                    i, maxRetries, method, backoff)
                time.Sleep(backoff)
            }
            
            err := invoker(ctx, method, req, reply, cc, opts...)
            
            if err == nil {
                return nil
            }
            
            lastErr = err
            
            // 재시도 가능한 에러인지 확인
            if !isRetryable(err) {
                return err
            }
        }
        
        return lastErr
    }
}

// TimeoutInterceptor - 타임아웃 인터셉터
func TimeoutInterceptor(timeout time.Duration) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // 타임아웃 컨텍스트 생성
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
        
        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

// MetadataInterceptor - 메타데이터 추가
func MetadataInterceptor() grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // 메타데이터 추가
        md := metadata.Pairs(
            "request-id", generateRequestID(),
            "client-version", "1.0.0",
            "timestamp", time.Now().Format(time.RFC3339),
        )
        
        ctx = metadata.NewOutgoingContext(ctx, md)
        
        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

// CircuitBreakerInterceptor - 서킷 브레이커
func CircuitBreakerInterceptor(cb CircuitBreaker) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // 서킷 브레이커 상태 확인
        if !cb.Allow() {
            return status.Error(codes.Unavailable, "서킷 브레이커 열림")
        }
        
        err := invoker(ctx, method, req, reply, cc, opts...)
        
        // 결과 기록
        if err != nil {
            cb.RecordFailure()
        } else {
            cb.RecordSuccess()
        }
        
        return err
    }
}
```

### Stream Client Interceptor

```go
// interceptors/stream_client_interceptors.go
package interceptors

import (
    "context"
    "log"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

// StreamClientLoggingInterceptor - 스트림 클라이언트 로깅
func StreamClientLoggingInterceptor() grpc.StreamClientInterceptor {
    return func(
        ctx context.Context,
        desc *grpc.StreamDesc,
        cc *grpc.ClientConn,
        method string,
        streamer grpc.Streamer,
        opts ...grpc.CallOption,
    ) (grpc.ClientStream, error) {
        log.Printf("스트림 RPC 시작: %s", method)
        
        // 스트림 생성
        clientStream, err := streamer(ctx, desc, cc, method, opts...)
        if err != nil {
            return nil, err
        }
        
        // 래퍼 스트림 반환
        return &loggingClientStream{
            ClientStream: clientStream,
            method:       method,
        }, nil
    }
}

type loggingClientStream struct {
    grpc.ClientStream
    method string
}

func (s *loggingClientStream) SendMsg(m interface{}) error {
    log.Printf("[%s] 클라이언트 메시지 전송: %T", s.method, m)
    return s.ClientStream.SendMsg(m)
}

func (s *loggingClientStream) RecvMsg(m interface{}) error {
    err := s.ClientStream.RecvMsg(m)
    if err == nil {
        log.Printf("[%s] 클라이언트 메시지 수신: %T", s.method, m)
    }
    return err
}

// StreamMetadataInterceptor - 스트림 메타데이터
func StreamMetadataInterceptor() grpc.StreamClientInterceptor {
    return func(
        ctx context.Context,
        desc *grpc.StreamDesc,
        cc *grpc.ClientConn,
        method string,
        streamer grpc.Streamer,
        opts ...grpc.CallOption,
    ) (grpc.ClientStream, error) {
        // 메타데이터 추가
        md := metadata.Pairs(
            "stream-id", generateStreamID(),
            "client-type", "streaming",
        )
        
        ctx = metadata.NewOutgoingContext(ctx, md)
        
        return streamer(ctx, desc, cc, method, opts...)
    }
}
```

## 3. 인터셉터 체인

### 서버 인터셉터 체인

```go
// server/interceptor_chain.go
package main

import (
    "grpc-server/interceptors"
    
    "google.golang.org/grpc"
    "github.com/grpc-ecosystem/go-grpc-middleware"
)

func createServerWithInterceptors() *grpc.Server {
    // Unary 인터셉터 체인
    unaryInterceptors := []grpc.UnaryServerInterceptor{
        interceptors.RecoveryInterceptor(),      // 1. 패닉 복구
        interceptors.LoggingInterceptor(),        // 2. 로깅
        interceptors.MetricsInterceptor(metrics), // 3. 메트릭
        interceptors.RateLimitInterceptor(limiter), // 4. 속도 제한
        interceptors.AuthenticationInterceptor(authFunc), // 5. 인증
        interceptors.ValidationInterceptor(),     // 6. 검증
    }
    
    // Stream 인터셉터 체인
    streamInterceptors := []grpc.StreamServerInterceptor{
        interceptors.StreamRecoveryInterceptor(),
        interceptors.StreamLoggingInterceptor(),
        interceptors.StreamAuthInterceptor(authFunc),
    }
    
    // 서버 옵션
    opts := []grpc.ServerOption{
        grpc.UnaryInterceptor(
            grpc_middleware.ChainUnaryServer(unaryInterceptors...),
        ),
        grpc.StreamInterceptor(
            grpc_middleware.ChainStreamServer(streamInterceptors...),
        ),
    }
    
    return grpc.NewServer(opts...)
}
```

### 클라이언트 인터셉터 체인

```go
// client/interceptor_chain.go
package main

import (
    "time"
    "grpc-client/interceptors"
    
    "google.golang.org/grpc"
    "github.com/grpc-ecosystem/go-grpc-middleware"
)

func createClientWithInterceptors(target string) (*grpc.ClientConn, error) {
    // Unary 인터셉터 체인
    unaryInterceptors := []grpc.UnaryClientInterceptor{
        interceptors.ClientLoggingInterceptor(),
        interceptors.MetadataInterceptor(),
        interceptors.TimeoutInterceptor(30 * time.Second),
        interceptors.RetryInterceptor(3),
        interceptors.CircuitBreakerInterceptor(cb),
    }
    
    // Stream 인터셉터 체인
    streamInterceptors := []grpc.StreamClientInterceptor{
        interceptors.StreamClientLoggingInterceptor(),
        interceptors.StreamMetadataInterceptor(),
    }
    
    // 연결 옵션
    opts := []grpc.DialOption{
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(
            grpc_middleware.ChainUnaryClient(unaryInterceptors...),
        ),
        grpc.WithStreamInterceptor(
            grpc_middleware.ChainStreamClient(streamInterceptors...),
        ),
    }
    
    return grpc.Dial(target, opts...)
}
```

## 4. 고급 인터셉터 패턴

### 조건부 인터셉터

```go
// interceptors/conditional.go
package interceptors

import (
    "context"
    "strings"
    
    "google.golang.org/grpc"
)

// ConditionalInterceptor - 조건부 실행
func ConditionalInterceptor(
    condition func(*grpc.UnaryServerInfo) bool,
    interceptor grpc.UnaryServerInterceptor,
) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        if condition(info) {
            return interceptor(ctx, req, info, handler)
        }
        return handler(ctx, req)
    }
}

// 사용 예제
func setupConditionalInterceptors() []grpc.UnaryServerInterceptor {
    // /admin 경로만 관리자 인증
    adminAuth := ConditionalInterceptor(
        func(info *grpc.UnaryServerInfo) bool {
            return strings.HasPrefix(info.FullMethod, "/admin")
        },
        AdminAuthInterceptor(),
    )
    
    // 디버그 모드에서만 상세 로깅
    debugLogging := ConditionalInterceptor(
        func(info *grpc.UnaryServerInfo) bool {
            return debugMode
        },
        VerboseLoggingInterceptor(),
    )
    
    return []grpc.UnaryServerInterceptor{adminAuth, debugLogging}
}
```

### 컨텍스트 전파

```go
// interceptors/context_propagation.go
package interceptors

import (
    "context"
    
    "google.golang.org/grpc"
)

type contextKey string

const (
    userIDKey    contextKey = "user_id"
    requestIDKey contextKey = "request_id"
    tenantIDKey  contextKey = "tenant_id"
)

// ContextPropagationInterceptor - 컨텍스트 값 전파
func ContextPropagationInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 메타데이터에서 값 추출
        md, _ := metadata.FromIncomingContext(ctx)
        
        // 컨텍스트에 값 저장
        if userID := md.Get("user-id"); len(userID) > 0 {
            ctx = context.WithValue(ctx, userIDKey, userID[0])
        }
        
        if requestID := md.Get("request-id"); len(requestID) > 0 {
            ctx = context.WithValue(ctx, requestIDKey, requestID[0])
        }
        
        return handler(ctx, req)
    }
}

// 컨텍스트에서 값 추출
func GetUserID(ctx context.Context) string {
    if v := ctx.Value(userIDKey); v != nil {
        return v.(string)
    }
    return ""
}
```

### 캐싱 인터셉터

```go
// interceptors/caching.go
package interceptors

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "google.golang.org/grpc"
)

type Cache interface {
    Get(key string) (interface{}, bool)
    Set(key string, value interface{}, ttl time.Duration)
}

// CachingInterceptor - 응답 캐싱
func CachingInterceptor(cache Cache) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 캐시 가능한 메서드인지 확인
        if !isCacheable(info.FullMethod) {
            return handler(ctx, req)
        }
        
        // 캐시 키 생성
        cacheKey := generateCacheKey(info.FullMethod, req)
        
        // 캐시 확인
        if cached, found := cache.Get(cacheKey); found {
            log.Printf("캐시 히트: %s", cacheKey)
            return cached, nil
        }
        
        // 핸들러 실행
        resp, err := handler(ctx, req)
        
        // 성공시 캐시 저장
        if err == nil {
            cache.Set(cacheKey, resp, 5*time.Minute)
        }
        
        return resp, err
    }
}
```

## 5. 헬퍼 유틸리티

```go
// interceptors/helpers.go
package interceptors

import (
    "context"
    "fmt"
    "strings"
    
    "github.com/google/uuid"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/status"
)

// Request ID 생성
func generateRequestID() string {
    return uuid.New().String()
}

// 메타데이터에서 Request ID 추출
func getRequestID(md metadata.MD) string {
    if values := md.Get("request-id"); len(values) > 0 {
        return values[0]
    }
    return generateRequestID()
}

// 재시도 가능한 에러 확인
func isRetryable(err error) bool {
    st, ok := status.FromError(err)
    if !ok {
        return false
    }
    
    switch st.Code() {
    case codes.Unavailable, codes.DeadlineExceeded, codes.Aborted:
        return true
    default:
        return false
    }
}

// 공개 메서드 확인
func isPublicMethod(fullMethod string) bool {
    publicMethods := []string{
        "/health/Check",
        "/auth/Login",
        "/auth/Register",
    }
    
    for _, method := range publicMethods {
        if strings.HasSuffix(fullMethod, method) {
            return true
        }
    }
    
    return false
}

// RateLimiter 인터페이스
type RateLimiter interface {
    Allow(clientID string) bool
}

// MetricsCollector 인터페이스
type MetricsCollector interface {
    IncrementRequestCount(method string)
    IncrementErrorCount(method string)
    RecordLatency(method string, duration time.Duration)
}

// CircuitBreaker 인터페이스
type CircuitBreaker interface {
    Allow() bool
    RecordSuccess()
    RecordFailure()
}
```

## 6. 실제 사용 예제

```go
// main.go
package main

import (
    "context"
    "log"
    "net"
    
    pb "myapp/pb"
    "myapp/interceptors"
    
    "google.golang.org/grpc"
)

func main() {
    // 인증 함수
    authFunc := func(ctx context.Context) error {
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok {
            return fmt.Errorf("메타데이터 없음")
        }
        
        token := md.Get("authorization")
        if len(token) == 0 {
            return fmt.Errorf("토큰 없음")
        }
        
        // 토큰 검증 로직
        return validateToken(token[0])
    }
    
    // 서버 생성 (인터셉터 포함)
    server := grpc.NewServer(
        grpc.ChainUnaryInterceptor(
            interceptors.RecoveryInterceptor(),
            interceptors.LoggingInterceptor(),
            interceptors.AuthenticationInterceptor(authFunc),
            interceptors.ValidationInterceptor(),
            interceptors.RateLimitInterceptor(NewRateLimiter()),
        ),
        grpc.ChainStreamInterceptor(
            interceptors.StreamRecoveryInterceptor(),
            interceptors.StreamLoggingInterceptor(),
            interceptors.StreamAuthInterceptor(authFunc),
        ),
    )
    
    // 서비스 등록
    pb.RegisterUserServiceServer(server, NewUserService())
    
    // 서버 시작
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("리스너 생성 실패: %v", err)
    }
    
    log.Println("서버 시작 (인터셉터 활성화)")
    if err := server.Serve(lis); err != nil {
        log.Fatalf("서버 실행 실패: %v", err)
    }
}
```

## Best Practices

1. **순서 중요**: 인터셉터 실행 순서 신중히 결정
2. **성능 고려**: 가벼운 인터셉터를 앞쪽에 배치
3. **에러 처리**: 적절한 에러 코드와 메시지 사용
4. **컨텍스트 활용**: 요청 범위 데이터 전달
5. **테스트**: 인터셉터 단위 테스트 작성
6. **모니터링**: 메트릭 수집 인터셉터 구현
7. **재사용성**: 범용 인터셉터 라이브러리화

## 다음 단계

인터셉터를 마스터했다면:
1. 에러 처리 및 모니터링
2. 성능 최적화
3. 프로덕션 배포
4. 보안 강화

## 참고 자료

- [gRPC Go Interceptors](https://github.com/grpc/grpc-go/tree/master/examples/features/interceptor)
- [go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)
- [gRPC Best Practices](https://grpc.io/docs/guides/)