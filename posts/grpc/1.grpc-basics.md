# gRPC 기초 개념

## gRPC란?

gRPC(gRPC Remote Procedure Calls)는 Google이 개발한 오픈소스 고성능 RPC(Remote Procedure Call) 프레임워크입니다. HTTP/2를 기반으로 하며, Protocol Buffers를 기본 직렬화 메커니즘으로 사용합니다.

## 왜 gRPC를 사용하는가?

### 기존 REST API의 한계
- JSON 직렬화/역직렬화 오버헤드
- HTTP/1.1의 성능 제약
- 스트리밍 지원 부족
- 타입 안정성 부재

### gRPC의 장점
1. **고성능**: Protocol Buffers를 통한 효율적인 직렬화
2. **HTTP/2 기반**: 멀티플렉싱, 서버 푸시, 헤더 압축
3. **스트리밍 지원**: 클라이언트, 서버, 양방향 스트리밍
4. **언어 중립적**: 다양한 프로그래밍 언어 지원
5. **강타입**: 컴파일 타임 타입 체크

## gRPC vs REST 비교

| 특징 | gRPC | REST |
|-----|------|------|
| 프로토콜 | HTTP/2 | HTTP/1.1, HTTP/2 |
| 데이터 형식 | Protocol Buffers (바이너리) | JSON, XML (텍스트) |
| 스트리밍 | 네이티브 지원 | 제한적 (SSE, WebSocket) |
| 브라우저 지원 | gRPC-Web 필요 | 네이티브 지원 |
| 성능 | 높음 | 보통 |
| 가독성 | 바이너리 (낮음) | 텍스트 (높음) |

## gRPC 아키텍처

```
┌─────────────┐          ┌─────────────┐
│   Client    │          │   Server    │
├─────────────┤          ├─────────────┤
│   Stub      │          │  Service    │
├─────────────┤          ├─────────────┤
│   Channel   │◄────────►│   Server    │
├─────────────┤ HTTP/2   ├─────────────┤
│  Transport  │          │  Transport  │
└─────────────┘          └─────────────┘
```

### 주요 구성 요소

1. **Service Definition (.proto)**
   - 서비스 인터페이스 정의
   - 메시지 타입 정의
   - RPC 메서드 정의

2. **Protocol Buffers**
   - 구조화된 데이터 직렬화
   - 언어 중립적 스키마

3. **Generated Code**
   - proto 파일로부터 자동 생성
   - 클라이언트 Stub과 서버 인터페이스

4. **Channel**
   - 클라이언트와 서버 간 연결
   - 연결 관리 및 로드 밸런싱

## gRPC 통신 패턴

### 1. Unary RPC (단일 요청-응답)
```go
rpc GetUser(UserRequest) returns (UserResponse);
```
- 가장 일반적인 패턴
- REST API와 유사

### 2. Server Streaming RPC
```go
rpc ListUsers(ListRequest) returns (stream User);
```
- 서버가 스트림으로 여러 응답 전송
- 대용량 데이터 전송에 유용

### 3. Client Streaming RPC
```go
rpc UploadFile(stream Chunk) returns (UploadStatus);
```
- 클라이언트가 스트림으로 여러 요청 전송
- 파일 업로드 등에 활용

### 4. Bidirectional Streaming RPC
```go
rpc Chat(stream Message) returns (stream Message);
```
- 양방향 스트리밍
- 실시간 통신에 적합

## gRPC 사용 사례

### 적합한 경우
- **마이크로서비스 간 통신**: 내부 서비스 통신
- **실시간 통신**: 채팅, 게임, 라이브 스트리밍
- **모바일 애플리케이션**: 배터리 효율, 네트워크 최적화
- **IoT 디바이스**: 리소스 제약 환경
- **다국어 시스템**: Polyglot 아키텍처

### 부적합한 경우
- **브라우저 직접 통신**: gRPC-Web 추가 필요
- **텍스트 기반 디버깅**: 바이너리 프로토콜
- **방화벽 제약**: HTTP/2 지원 필요
- **캐싱이 중요한 경우**: REST가 더 적합

## 설치 및 환경 설정

### Go 환경 설정
```bash
# Protocol Buffer 컴파일러 설치
brew install protobuf

# Go 플러그인 설치
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

# PATH 설정
export PATH="$PATH:$(go env GOPATH)/bin"
```

### 프로젝트 초기화
```bash
# 프로젝트 생성
mkdir grpc-example && cd grpc-example
go mod init github.com/yourusername/grpc-example

# gRPC 패키지 설치
go get google.golang.org/grpc
go get google.golang.org/protobuf
```

## 첫 번째 proto 파일

```protobuf
syntax = "proto3";

package hello;
option go_package = "./pb";

// 서비스 정의
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

// 메시지 정의
message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

### 코드 생성
```bash
protoc --go_out=. --go-grpc_out=. hello.proto
```

## 핵심 개념 정리

### Protocol Buffers
- 구조화된 데이터를 직렬화하는 언어 중립적 메커니즘
- JSON보다 3-10배 작고, 20-100배 빠름
- 스키마 진화 지원 (backward/forward compatibility)

### HTTP/2 특징
- **멀티플렉싱**: 단일 연결로 여러 요청/응답
- **서버 푸시**: 클라이언트 요청 없이 리소스 전송
- **헤더 압축**: HPACK 압축으로 오버헤드 감소
- **바이너리 프로토콜**: 파싱 효율성 향상

### 메타데이터
- 요청/응답과 함께 전송되는 키-값 쌍
- 인증, 추적, 모니터링 정보 전달
- HTTP 헤더와 유사한 역할

## 다음 단계

1. Protocol Buffers 심화 학습
2. gRPC 서버 구현
3. gRPC 클라이언트 구현
4. 스트리밍 패턴 구현
5. 인터셉터와 미들웨어
6. 에러 처리 및 모니터링

## 참고 자료

- [gRPC 공식 문서](https://grpc.io/)
- [Protocol Buffers 가이드](https://developers.google.com/protocol-buffers)
- [gRPC Go 튜토리얼](https://grpc.io/docs/languages/go/)
- [HTTP/2 스펙](https://http2.github.io/)