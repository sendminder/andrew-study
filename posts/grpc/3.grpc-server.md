# gRPC 서버 구현 완벽 가이드

## 서버 구현 개요

gRPC 서버는 Protocol Buffers로 정의된 서비스를 구현하고, 클라이언트의 RPC 호출을 처리합니다. Go에서는 생성된 인터페이스를 구현하여 서버를 만듭니다.

## 프로젝트 구조

```
grpc-server/
├── proto/
│   └── user.proto
├── pb/
│   ├── user.pb.go
│   └── user_grpc.pb.go
├── server/
│   ├── main.go
│   └── handler.go
├── config/
│   └── config.go
├── go.mod
└── go.sum
```

## 1. Proto 파일 정의

```protobuf
// proto/user.proto
syntax = "proto3";

package user;
option go_package = "./pb";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// 사용자 서비스 정의
service UserService {
  // Unary RPC
  rpc CreateUser(CreateUserRequest) returns (User);
  rpc GetUser(GetUserRequest) returns (User);
  rpc UpdateUser(UpdateUserRequest) returns (User);
  rpc DeleteUser(DeleteUserRequest) returns (google.protobuf.Empty);
  
  // Server Streaming
  rpc ListUsers(ListUsersRequest) returns (stream User);
  
  // Client Streaming
  rpc CreateUsers(stream CreateUserRequest) returns (CreateUsersResponse);
  
  // Bidirectional Streaming
  rpc UserChat(stream ChatMessage) returns (stream ChatMessage);
}

// 메시지 정의
message User {
  int32 id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

message CreateUserRequest {
  string username = 1;
  string email = 2;
  string full_name = 3;
  string password = 4;
}

message GetUserRequest {
  int32 id = 1;
}

message UpdateUserRequest {
  int32 id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
}

message DeleteUserRequest {
  int32 id = 1;
}

message ListUsersRequest {
  int32 page_size = 1;
  int32 page = 2;
}

message CreateUsersResponse {
  int32 created_count = 1;
  repeated int32 user_ids = 2;
}

message ChatMessage {
  int32 user_id = 1;
  string message = 2;
  google.protobuf.Timestamp timestamp = 3;
}
```

## 2. 코드 생성

```bash
# pb 디렉토리 생성
mkdir -p pb

# Protocol Buffer 코드 생성
protoc --go_out=./pb --go_opt=paths=source_relative \
       --go-grpc_out=./pb --go-grpc_opt=paths=source_relative \
       proto/user.proto
```

## 3. 서버 구현

### 기본 서버 구조

```go
// server/handler.go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "sync"
    "time"
    
    pb "grpc-server/pb"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "google.golang.org/protobuf/types/known/emptypb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

// 서버 구조체
type UserServer struct {
    pb.UnimplementedUserServiceServer
    mu    sync.RWMutex
    users map[int32]*pb.User
    nextID int32
}

// NewUserServer 생성자
func NewUserServer() *UserServer {
    return &UserServer{
        users:  make(map[int32]*pb.User),
        nextID: 1,
    }
}
```

### Unary RPC 구현

```go
// CreateUser - 단일 사용자 생성
func (s *UserServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.User, error) {
    // 입력 검증
    if req.Username == "" {
        return nil, status.Errorf(codes.InvalidArgument, "username은 필수입니다")
    }
    if req.Email == "" {
        return nil, status.Errorf(codes.InvalidArgument, "email은 필수입니다")
    }
    
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 중복 검사
    for _, user := range s.users {
        if user.Email == req.Email {
            return nil, status.Errorf(codes.AlreadyExists, "email이 이미 존재합니다: %s", req.Email)
        }
    }
    
    // 새 사용자 생성
    now := timestamppb.Now()
    user := &pb.User{
        Id:        s.nextID,
        Username:  req.Username,
        Email:     req.Email,
        FullName:  req.FullName,
        CreatedAt: now,
        UpdatedAt: now,
    }
    
    s.users[s.nextID] = user
    s.nextID++
    
    log.Printf("사용자 생성됨: ID=%d, Username=%s", user.Id, user.Username)
    return user, nil
}

// GetUser - 사용자 조회
func (s *UserServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    user, exists := s.users[req.Id]
    if !exists {
        return nil, status.Errorf(codes.NotFound, "사용자를 찾을 수 없습니다: ID=%d", req.Id)
    }
    
    return user, nil
}

// UpdateUser - 사용자 수정
func (s *UserServer) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.User, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    user, exists := s.users[req.Id]
    if !exists {
        return nil, status.Errorf(codes.NotFound, "사용자를 찾을 수 없습니다: ID=%d", req.Id)
    }
    
    // 업데이트 수행
    if req.Username != "" {
        user.Username = req.Username
    }
    if req.Email != "" {
        user.Email = req.Email
    }
    if req.FullName != "" {
        user.FullName = req.FullName
    }
    user.UpdatedAt = timestamppb.Now()
    
    log.Printf("사용자 수정됨: ID=%d", user.Id)
    return user, nil
}

// DeleteUser - 사용자 삭제
func (s *UserServer) DeleteUser(ctx context.Context, req *pb.DeleteUserRequest) (*emptypb.Empty, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if _, exists := s.users[req.Id]; !exists {
        return nil, status.Errorf(codes.NotFound, "사용자를 찾을 수 없습니다: ID=%d", req.Id)
    }
    
    delete(s.users, req.Id)
    log.Printf("사용자 삭제됨: ID=%d", req.Id)
    
    return &emptypb.Empty{}, nil
}
```

### Server Streaming RPC 구현

```go
// ListUsers - 서버 스트리밍으로 사용자 목록 전송
func (s *UserServer) ListUsers(req *pb.ListUsersRequest, stream pb.UserService_ListUsersServer) error {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    // 페이지네이션 설정
    pageSize := req.PageSize
    if pageSize <= 0 {
        pageSize = 10
    }
    
    page := req.Page
    if page <= 0 {
        page = 1
    }
    
    start := (page - 1) * pageSize
    count := int32(0)
    
    // 사용자를 스트림으로 전송
    for id := int32(1); id < s.nextID; id++ {
        user, exists := s.users[id]
        if !exists {
            continue
        }
        
        // 페이지네이션 적용
        if count < start {
            count++
            continue
        }
        
        if count >= start+pageSize {
            break
        }
        
        // 스트림으로 전송
        if err := stream.Send(user); err != nil {
            return status.Errorf(codes.Internal, "스트림 전송 실패: %v", err)
        }
        
        count++
        
        // 스트리밍 효과를 위한 지연 (실제로는 제거)
        time.Sleep(100 * time.Millisecond)
    }
    
    return nil
}
```

### Client Streaming RPC 구현

```go
// CreateUsers - 클라이언트 스트리밍으로 여러 사용자 생성
func (s *UserServer) CreateUsers(stream pb.UserService_CreateUsersServer) error {
    var createdIDs []int32
    createdCount := int32(0)
    
    for {
        req, err := stream.Recv()
        if err == io.EOF {
            // 스트림 종료, 결과 반환
            return stream.SendAndClose(&pb.CreateUsersResponse{
                CreatedCount: createdCount,
                UserIds:      createdIDs,
            })
        }
        if err != nil {
            return status.Errorf(codes.Internal, "스트림 수신 실패: %v", err)
        }
        
        // 사용자 생성
        s.mu.Lock()
        now := timestamppb.Now()
        user := &pb.User{
            Id:        s.nextID,
            Username:  req.Username,
            Email:     req.Email,
            FullName:  req.FullName,
            CreatedAt: now,
            UpdatedAt: now,
        }
        
        s.users[s.nextID] = user
        createdIDs = append(createdIDs, s.nextID)
        s.nextID++
        createdCount++
        s.mu.Unlock()
        
        log.Printf("스트림으로 사용자 생성: ID=%d, Username=%s", user.Id, user.Username)
    }
}
```

### Bidirectional Streaming RPC 구현

```go
// UserChat - 양방향 스트리밍 채팅
func (s *UserServer) UserChat(stream pb.UserService_UserChatServer) error {
    for {
        // 클라이언트로부터 메시지 수신
        msg, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return status.Errorf(codes.Internal, "스트림 수신 실패: %v", err)
        }
        
        // 메시지 처리
        log.Printf("채팅 메시지 수신: UserID=%d, Message=%s", msg.UserId, msg.Message)
        
        // 응답 메시지 생성
        response := &pb.ChatMessage{
            UserId:    msg.UserId,
            Message:   fmt.Sprintf("서버 응답: %s", msg.Message),
            Timestamp: timestamppb.Now(),
        }
        
        // 클라이언트로 응답 전송
        if err := stream.Send(response); err != nil {
            return status.Errorf(codes.Internal, "스트림 전송 실패: %v", err)
        }
    }
}
```

## 4. 메인 서버

```go
// server/main.go
package main

import (
    "flag"
    "fmt"
    "log"
    "net"
    "os"
    "os/signal"
    "syscall"
    
    pb "grpc-server/pb"
    "google.golang.org/grpc"
    "google.golang.org/grpc/reflection"
    "google.golang.org/grpc/health"
    "google.golang.org/grpc/health/grpc_health_v1"
)

var (
    port = flag.Int("port", 50051, "서버 포트")
)

func main() {
    flag.Parse()
    
    // TCP 리스너 생성
    lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
    if err != nil {
        log.Fatalf("리스너 생성 실패: %v", err)
    }
    
    // gRPC 서버 옵션
    opts := []grpc.ServerOption{
        grpc.MaxRecvMsgSize(1024 * 1024 * 10), // 10MB
        grpc.MaxSendMsgSize(1024 * 1024 * 10), // 10MB
    }
    
    // gRPC 서버 생성
    grpcServer := grpc.NewServer(opts...)
    
    // 서비스 등록
    userServer := NewUserServer()
    pb.RegisterUserServiceServer(grpcServer, userServer)
    
    // 헬스 체크 서비스 등록
    healthServer := health.NewServer()
    grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)
    healthServer.SetServingStatus("UserService", grpc_health_v1.HealthCheckResponse_SERVING)
    
    // Reflection 등록 (디버깅용)
    reflection.Register(grpcServer)
    
    // Graceful Shutdown 설정
    go func() {
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
        <-sigChan
        
        log.Println("서버 종료 중...")
        grpcServer.GracefulStop()
    }()
    
    log.Printf("gRPC 서버 시작: 포트 %d", *port)
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("서버 실행 실패: %v", err)
    }
}
```

## 5. TLS/SSL 보안 설정

```go
// server/tls_server.go
package main

import (
    "crypto/tls"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
)

func createTLSServer() (*grpc.Server, error) {
    // TLS 인증서 로드
    cert, err := tls.LoadX509KeyPair("server.crt", "server.key")
    if err != nil {
        return nil, err
    }
    
    // TLS 설정
    config := &tls.Config{
        Certificates: []tls.Certificate{cert},
        ClientAuth:   tls.RequireAndVerifyClientCert,
    }
    
    // TLS credentials 생성
    creds := credentials.NewTLS(config)
    
    // TLS 옵션으로 서버 생성
    opts := []grpc.ServerOption{
        grpc.Creds(creds),
    }
    
    return grpc.NewServer(opts...), nil
}
```

## 6. 서버 설정 관리

```go
// config/config.go
package config

import (
    "os"
    "strconv"
    "time"
)

type ServerConfig struct {
    Port            int
    MaxConnections  int
    ReadTimeout     time.Duration
    WriteTimeout    time.Duration
    IdleTimeout     time.Duration
    MaxMessageSize  int
    EnableTLS       bool
    CertFile        string
    KeyFile         string
}

func LoadConfig() *ServerConfig {
    return &ServerConfig{
        Port:           getEnvAsInt("GRPC_PORT", 50051),
        MaxConnections: getEnvAsInt("MAX_CONNECTIONS", 1000),
        ReadTimeout:    getEnvAsDuration("READ_TIMEOUT", 10*time.Second),
        WriteTimeout:   getEnvAsDuration("WRITE_TIMEOUT", 10*time.Second),
        IdleTimeout:    getEnvAsDuration("IDLE_TIMEOUT", 60*time.Second),
        MaxMessageSize: getEnvAsInt("MAX_MESSAGE_SIZE", 10*1024*1024),
        EnableTLS:      getEnvAsBool("ENABLE_TLS", false),
        CertFile:       getEnv("CERT_FILE", "server.crt"),
        KeyFile:        getEnv("KEY_FILE", "server.key"),
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
    valueStr := getEnv(key, "")
    if value, err := strconv.Atoi(valueStr); err == nil {
        return value
    }
    return defaultValue
}

func getEnvAsBool(key string, defaultValue bool) bool {
    valueStr := getEnv(key, "")
    if value, err := strconv.ParseBool(valueStr); err == nil {
        return value
    }
    return defaultValue
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration {
    valueStr := getEnv(key, "")
    if value, err := time.ParseDuration(valueStr); err == nil {
        return value
    }
    return defaultValue
}
```

## 7. 데이터베이스 연동

```go
// server/db_handler.go
package main

import (
    "context"
    "database/sql"
    
    pb "grpc-server/pb"
    _ "github.com/lib/pq"
    "google.golang.org/protobuf/types/known/timestamppb"
)

type DBUserServer struct {
    pb.UnimplementedUserServiceServer
    db *sql.DB
}

func NewDBUserServer(db *sql.DB) *DBUserServer {
    return &DBUserServer{db: db}
}

func (s *DBUserServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.User, error) {
    var user pb.User
    
    query := `
        INSERT INTO users (username, email, full_name, created_at, updated_at)
        VALUES ($1, $2, $3, NOW(), NOW())
        RETURNING id, username, email, full_name, created_at, updated_at
    `
    
    var createdAt, updatedAt time.Time
    err := s.db.QueryRowContext(ctx, query,
        req.Username, req.Email, req.FullName,
    ).Scan(
        &user.Id, &user.Username, &user.Email, &user.FullName,
        &createdAt, &updatedAt,
    )
    
    if err != nil {
        return nil, status.Errorf(codes.Internal, "데이터베이스 오류: %v", err)
    }
    
    user.CreatedAt = timestamppb.New(createdAt)
    user.UpdatedAt = timestamppb.New(updatedAt)
    
    return &user, nil
}
```

## 8. 테스트

```go
// server/handler_test.go
package main

import (
    "context"
    "testing"
    
    pb "grpc-server/pb"
    "github.com/stretchr/testify/assert"
    "google.golang.org/grpc"
    "google.golang.org/grpc/test/bufconn"
)

func TestCreateUser(t *testing.T) {
    // 테스트 서버 설정
    server := NewUserServer()
    
    // 테스트 요청
    req := &pb.CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
        FullName: "Test User",
    }
    
    // 실행
    user, err := server.CreateUser(context.Background(), req)
    
    // 검증
    assert.NoError(t, err)
    assert.NotNil(t, user)
    assert.Equal(t, "testuser", user.Username)
    assert.Equal(t, "test@example.com", user.Email)
}

// In-memory 연결을 사용한 통합 테스트
func TestUserServiceIntegration(t *testing.T) {
    // BuffConn 설정
    lis := bufconn.Listen(1024 * 1024)
    server := grpc.NewServer()
    pb.RegisterUserServiceServer(server, NewUserServer())
    
    go func() {
        if err := server.Serve(lis); err != nil {
            t.Errorf("서버 실행 실패: %v", err)
        }
    }()
    
    // 클라이언트 연결
    conn, err := grpc.DialContext(context.Background(), "bufnet",
        grpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {
            return lis.Dial()
        }),
        grpc.WithInsecure(),
    )
    assert.NoError(t, err)
    defer conn.Close()
    
    client := pb.NewUserServiceClient(conn)
    
    // 테스트 실행
    user, err := client.CreateUser(context.Background(), &pb.CreateUserRequest{
        Username: "integrationtest",
        Email:    "integration@test.com",
    })
    
    assert.NoError(t, err)
    assert.NotNil(t, user)
}
```

## 실행 및 테스트

### 서버 실행
```bash
# 일반 실행
go run server/*.go

# 포트 지정
go run server/*.go -port=8080

# Docker 실행
docker build -t grpc-server .
docker run -p 50051:50051 grpc-server
```

### grpcurl로 테스트
```bash
# 서비스 목록 확인
grpcurl -plaintext localhost:50051 list

# 메서드 목록 확인
grpcurl -plaintext localhost:50051 list user.UserService

# 사용자 생성
grpcurl -plaintext -d '{"username":"andrew","email":"andrew@example.com"}' \
  localhost:50051 user.UserService/CreateUser

# 사용자 조회
grpcurl -plaintext -d '{"id":1}' \
  localhost:50051 user.UserService/GetUser
```

## Best Practices

1. **에러 처리**: gRPC status 코드 적절히 사용
2. **동시성**: 고루틴 안전성 보장 (mutex 사용)
3. **컨텍스트**: 타임아웃과 취소 처리
4. **로깅**: 구조화된 로깅 사용
5. **모니터링**: 메트릭 수집 및 추적
6. **보안**: TLS 사용, 인증/인가 구현
7. **테스트**: 단위 테스트와 통합 테스트

## 다음 단계

서버 구현을 마쳤다면:
1. gRPC 클라이언트 구현
2. 스트리밍 패턴 심화
3. 인터셉터와 미들웨어
4. 에러 처리 및 모니터링

## 참고 자료

- [gRPC Go Quick Start](https://grpc.io/docs/languages/go/quickstart/)
- [gRPC Go API](https://pkg.go.dev/google.golang.org/grpc)
- [gRPC Best Practices](https://grpc.io/docs/guides/)