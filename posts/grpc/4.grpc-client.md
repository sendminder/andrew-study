# gRPC 클라이언트 구현 완벽 가이드

## 클라이언트 구현 개요

gRPC 클라이언트는 서버와 통신하여 원격 프로시저를 호출합니다. Go에서는 생성된 클라이언트 스텁을 사용하여 타입 안전한 방식으로 서버와 통신합니다.

## 1. 기본 클라이언트 구현

### 클라이언트 연결 설정

```go
// client/main.go
package main

import (
    "context"
    "log"
    "time"
    
    pb "grpc-client/pb"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func main() {
    // 서버 연결 옵션
    opts := []grpc.DialOption{
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithBlock(), // 연결될 때까지 대기
    }
    
    // 타임아웃 설정
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 서버 연결
    conn, err := grpc.DialContext(ctx, "localhost:50051", opts...)
    if err != nil {
        log.Fatalf("서버 연결 실패: %v", err)
    }
    defer conn.Close()
    
    // 클라이언트 생성
    client := pb.NewUserServiceClient(conn)
    
    // RPC 호출
    runUnaryRPC(client)
}
```

## 2. Unary RPC 클라이언트

```go
// client/unary_client.go
package main

import (
    "context"
    "log"
    "time"
    
    pb "grpc-client/pb"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

func runUnaryRPC(client pb.UserServiceClient) {
    // 1. 사용자 생성
    createUser(client)
    
    // 2. 사용자 조회
    getUser(client, 1)
    
    // 3. 사용자 수정
    updateUser(client, 1)
    
    // 4. 사용자 삭제
    deleteUser(client, 1)
}

// 사용자 생성
func createUser(client pb.UserServiceClient) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    req := &pb.CreateUserRequest{
        Username: "andrew",
        Email:    "andrew@example.com",
        FullName: "Andrew Kwon",
        Password: "securepassword",
    }
    
    user, err := client.CreateUser(ctx, req)
    if err != nil {
        handleError(err, "CreateUser")
        return
    }
    
    log.Printf("사용자 생성 성공: ID=%d, Username=%s", user.Id, user.Username)
}

// 사용자 조회
func getUser(client pb.UserServiceClient, userID int32) {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    req := &pb.GetUserRequest{Id: userID}
    
    user, err := client.GetUser(ctx, req)
    if err != nil {
        handleError(err, "GetUser")
        return
    }
    
    log.Printf("사용자 조회 성공: %+v", user)
}

// 사용자 수정
func updateUser(client pb.UserServiceClient, userID int32) {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    req := &pb.UpdateUserRequest{
        Id:       userID,
        Username: "andrew_updated",
        Email:    "andrew.new@example.com",
        FullName: "Andrew Kwon Updated",
    }
    
    user, err := client.UpdateUser(ctx, req)
    if err != nil {
        handleError(err, "UpdateUser")
        return
    }
    
    log.Printf("사용자 수정 성공: %+v", user)
}

// 사용자 삭제
func deleteUser(client pb.UserServiceClient, userID int32) {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    req := &pb.DeleteUserRequest{Id: userID}
    
    _, err := client.DeleteUser(ctx, req)
    if err != nil {
        handleError(err, "DeleteUser")
        return
    }
    
    log.Printf("사용자 삭제 성공: ID=%d", userID)
}

// 에러 처리
func handleError(err error, method string) {
    st, ok := status.FromError(err)
    if ok {
        log.Printf("%s 실패: Code=%s, Message=%s", method, st.Code(), st.Message())
        
        // 에러 코드별 처리
        switch st.Code() {
        case codes.NotFound:
            log.Println("리소스를 찾을 수 없습니다")
        case codes.InvalidArgument:
            log.Println("잘못된 인자입니다")
        case codes.AlreadyExists:
            log.Println("이미 존재하는 리소스입니다")
        case codes.DeadlineExceeded:
            log.Println("요청 시간이 초과되었습니다")
        default:
            log.Printf("알 수 없는 에러: %v", err)
        }
    } else {
        log.Printf("%s 실패: %v", method, err)
    }
}
```

## 3. Server Streaming 클라이언트

```go
// client/server_streaming_client.go
package main

import (
    "context"
    "io"
    "log"
    "time"
    
    pb "grpc-client/pb"
)

func runServerStreamingRPC(client pb.UserServiceClient) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // 스트림 요청
    req := &pb.ListUsersRequest{
        PageSize: 10,
        Page:     1,
    }
    
    stream, err := client.ListUsers(ctx, req)
    if err != nil {
        log.Fatalf("ListUsers 실패: %v", err)
    }
    
    // 스트림에서 데이터 수신
    count := 0
    for {
        user, err := stream.Recv()
        if err == io.EOF {
            // 스트림 종료
            break
        }
        if err != nil {
            log.Fatalf("스트림 수신 실패: %v", err)
        }
        
        count++
        log.Printf("사용자 수신 #%d: ID=%d, Username=%s", count, user.Id, user.Username)
    }
    
    log.Printf("총 %d명의 사용자를 수신했습니다", count)
}
```

## 4. Client Streaming 클라이언트

```go
// client/client_streaming_client.go
package main

import (
    "context"
    "fmt"
    "log"
    "time"
    
    pb "grpc-client/pb"
)

func runClientStreamingRPC(client pb.UserServiceClient) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // 스트림 생성
    stream, err := client.CreateUsers(ctx)
    if err != nil {
        log.Fatalf("CreateUsers 스트림 생성 실패: %v", err)
    }
    
    // 여러 사용자 데이터 전송
    users := []*pb.CreateUserRequest{
        {Username: "user1", Email: "user1@example.com", FullName: "User One"},
        {Username: "user2", Email: "user2@example.com", FullName: "User Two"},
        {Username: "user3", Email: "user3@example.com", FullName: "User Three"},
        {Username: "user4", Email: "user4@example.com", FullName: "User Four"},
        {Username: "user5", Email: "user5@example.com", FullName: "User Five"},
    }
    
    for _, user := range users {
        if err := stream.Send(user); err != nil {
            log.Fatalf("스트림 전송 실패: %v", err)
        }
        log.Printf("사용자 전송: %s", user.Username)
        
        // 스트리밍 효과를 위한 지연
        time.Sleep(500 * time.Millisecond)
    }
    
    // 스트림 종료 및 응답 수신
    response, err := stream.CloseAndRecv()
    if err != nil {
        log.Fatalf("스트림 종료 실패: %v", err)
    }
    
    log.Printf("생성 완료: %d명 생성, IDs: %v", response.CreatedCount, response.UserIds)
}
```

## 5. Bidirectional Streaming 클라이언트

```go
// client/bidirectional_streaming_client.go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "sync"
    "time"
    
    pb "grpc-client/pb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

func runBidirectionalStreamingRPC(client pb.UserServiceClient) {
    ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
    defer cancel()
    
    // 스트림 생성
    stream, err := client.UserChat(ctx)
    if err != nil {
        log.Fatalf("UserChat 스트림 생성 실패: %v", err)
    }
    
    // WaitGroup for goroutines
    var wg sync.WaitGroup
    wg.Add(2)
    
    // 메시지 수신 고루틴
    go func() {
        defer wg.Done()
        for {
            msg, err := stream.Recv()
            if err == io.EOF {
                return
            }
            if err != nil {
                log.Printf("스트림 수신 실패: %v", err)
                return
            }
            
            log.Printf("[수신] UserID=%d: %s", msg.UserId, msg.Message)
        }
    }()
    
    // 메시지 전송 고루틴
    go func() {
        defer wg.Done()
        messages := []string{
            "안녕하세요!",
            "gRPC 양방향 스트리밍 테스트입니다",
            "메시지를 주고받을 수 있습니다",
            "실시간 채팅이 가능합니다",
            "종료합니다",
        }
        
        for i, text := range messages {
            msg := &pb.ChatMessage{
                UserId:    int32(i + 1),
                Message:   text,
                Timestamp: timestamppb.Now(),
            }
            
            if err := stream.Send(msg); err != nil {
                log.Printf("스트림 전송 실패: %v", err)
                return
            }
            
            log.Printf("[전송] UserID=%d: %s", msg.UserId, msg.Message)
            time.Sleep(1 * time.Second)
        }
        
        stream.CloseSend()
    }()
    
    // 모든 고루틴 대기
    wg.Wait()
}
```

## 6. 고급 클라이언트 기능

### 연결 관리 및 재시도

```go
// client/connection_manager.go
package main

import (
    "context"
    "fmt"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/backoff"
    "google.golang.org/grpc/connectivity"
    "google.golang.org/grpc/keepalive"
)

type ConnectionManager struct {
    conn   *grpc.ClientConn
    target string
}

func NewConnectionManager(target string) (*ConnectionManager, error) {
    // 연결 옵션 설정
    opts := []grpc.DialOption{
        grpc.WithInsecure(),
        
        // Keep-alive 설정
        grpc.WithKeepaliveParams(keepalive.ClientParameters{
            Time:                10 * time.Second, // 10초마다 ping
            Timeout:             3 * time.Second,  // 3초 타임아웃
            PermitWithoutStream: true,
        }),
        
        // 재시도 정책
        grpc.WithConnectParams(grpc.ConnectParams{
            Backoff: backoff.Config{
                BaseDelay:  1.0 * time.Second,
                Multiplier: 1.6,
                Jitter:     0.2,
                MaxDelay:   120 * time.Second,
            },
            MinConnectTimeout: 20 * time.Second,
        }),
        
        // 기본 서비스 설정
        grpc.WithDefaultServiceConfig(`{
            "methodConfig": [{
                "name": [{"service": "user.UserService"}],
                "retryPolicy": {
                    "maxAttempts": 5,
                    "initialBackoff": "0.1s",
                    "maxBackoff": "10s",
                    "backoffMultiplier": 2,
                    "retryableStatusCodes": ["UNAVAILABLE", "DEADLINE_EXCEEDED"]
                }
            }]
        }`),
    }
    
    // 연결 생성
    conn, err := grpc.Dial(target, opts...)
    if err != nil {
        return nil, fmt.Errorf("연결 실패: %w", err)
    }
    
    return &ConnectionManager{
        conn:   conn,
        target: target,
    }, nil
}

func (cm *ConnectionManager) GetConnection() *grpc.ClientConn {
    return cm.conn
}

func (cm *ConnectionManager) WaitForReady(ctx context.Context) error {
    state := cm.conn.GetState()
    
    for state != connectivity.Ready {
        if !cm.conn.WaitForStateChange(ctx, state) {
            return fmt.Errorf("연결 타임아웃")
        }
        state = cm.conn.GetState()
    }
    
    return nil
}

func (cm *ConnectionManager) Close() error {
    return cm.conn.Close()
}

func (cm *ConnectionManager) IsHealthy() bool {
    state := cm.conn.GetState()
    return state == connectivity.Ready || state == connectivity.Idle
}
```

### 로드 밸런싱 클라이언트

```go
// client/load_balanced_client.go
package main

import (
    "google.golang.org/grpc"
    "google.golang.org/grpc/resolver"
)

func createLoadBalancedClient() (*grpc.ClientConn, error) {
    // 커스텀 리졸버 등록
    resolver.Register(&customResolverBuilder{})
    
    // 로드 밸런싱 설정
    opts := []grpc.DialOption{
        grpc.WithInsecure(),
        grpc.WithDefaultServiceConfig(`{
            "loadBalancingPolicy": "round_robin",
            "healthCheckConfig": {
                "serviceName": "user.UserService"
            }
        }`),
    }
    
    // 여러 서버 주소 (DNS 또는 커스텀 리졸버 사용)
    target := "custom:///userservice"
    
    return grpc.Dial(target, opts...)
}

// 커스텀 리졸버 구현
type customResolverBuilder struct{}

func (*customResolverBuilder) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, error) {
    r := &customResolver{cc: cc}
    r.start()
    return r, nil
}

func (*customResolverBuilder) Scheme() string { return "custom" }

type customResolver struct {
    cc resolver.ClientConn
}

func (r *customResolver) start() {
    // 서버 주소 목록
    addrs := []resolver.Address{
        {Addr: "localhost:50051"},
        {Addr: "localhost:50052"},
        {Addr: "localhost:50053"},
    }
    
    r.cc.UpdateState(resolver.State{Addresses: addrs})
}

func (*customResolver) ResolveNow(o resolver.ResolveNowOptions) {}
func (*customResolver) Close() {}
```

### 메타데이터 사용

```go
// client/metadata_client.go
package main

import (
    "context"
    "log"
    
    pb "grpc-client/pb"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

func callWithMetadata(client pb.UserServiceClient) {
    // 메타데이터 생성
    md := metadata.Pairs(
        "authorization", "Bearer your-token-here",
        "request-id", "12345",
        "client-version", "1.0.0",
    )
    
    // 컨텍스트에 메타데이터 추가
    ctx := metadata.NewOutgoingContext(context.Background(), md)
    
    // RPC 호출
    req := &pb.GetUserRequest{Id: 1}
    user, err := client.GetUser(ctx, req)
    if err != nil {
        log.Fatalf("GetUser 실패: %v", err)
    }
    
    log.Printf("사용자 조회 성공 (메타데이터 포함): %+v", user)
}

// 응답 메타데이터 처리
func handleResponseMetadata(client pb.UserServiceClient) {
    var header, trailer metadata.MD
    
    req := &pb.GetUserRequest{Id: 1}
    
    // Header와 Trailer 메타데이터 수신
    user, err := client.GetUser(
        context.Background(),
        req,
        grpc.Header(&header),
        grpc.Trailer(&trailer),
    )
    
    if err != nil {
        log.Fatalf("GetUser 실패: %v", err)
    }
    
    log.Printf("사용자: %+v", user)
    log.Printf("Header: %v", header)
    log.Printf("Trailer: %v", trailer)
}
```

### TLS/SSL 보안 연결

```go
// client/tls_client.go
package main

import (
    "crypto/tls"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
)

func createTLSClient(serverAddr string) (*grpc.ClientConn, error) {
    // TLS 설정
    config := &tls.Config{
        ServerName: "example.com", // 서버 인증서의 CN
    }
    
    // TLS credentials 생성
    creds := credentials.NewTLS(config)
    
    // TLS 옵션으로 연결
    opts := []grpc.DialOption{
        grpc.WithTransportCredentials(creds),
    }
    
    return grpc.Dial(serverAddr, opts...)
}

// 상호 TLS (mTLS) 클라이언트
func createMutualTLSClient(serverAddr string) (*grpc.ClientConn, error) {
    // 클라이언트 인증서 로드
    cert, err := tls.LoadX509KeyPair("client.crt", "client.key")
    if err != nil {
        return nil, err
    }
    
    config := &tls.Config{
        Certificates: []tls.Certificate{cert},
        ServerName:   "example.com",
    }
    
    creds := credentials.NewTLS(config)
    
    return grpc.Dial(serverAddr, grpc.WithTransportCredentials(creds))
}
```

## 7. 클라이언트 테스트

```go
// client/client_test.go
package main

import (
    "context"
    "testing"
    "time"
    
    pb "grpc-client/pb"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "google.golang.org/grpc"
)

// Mock 클라이언트
type MockUserServiceClient struct {
    mock.Mock
}

func (m *MockUserServiceClient) CreateUser(ctx context.Context, req *pb.CreateUserRequest, opts ...grpc.CallOption) (*pb.User, error) {
    args := m.Called(ctx, req)
    return args.Get(0).(*pb.User), args.Error(1)
}

func TestCreateUserClient(t *testing.T) {
    // Mock 설정
    mockClient := new(MockUserServiceClient)
    
    expectedUser := &pb.User{
        Id:       1,
        Username: "testuser",
        Email:    "test@example.com",
    }
    
    mockClient.On("CreateUser", mock.Anything, mock.Anything).Return(expectedUser, nil)
    
    // 테스트 실행
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    req := &pb.CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
    }
    
    user, err := mockClient.CreateUser(ctx, req)
    
    // 검증
    assert.NoError(t, err)
    assert.Equal(t, expectedUser.Id, user.Id)
    assert.Equal(t, expectedUser.Username, user.Username)
    
    mockClient.AssertExpectations(t)
}
```

## 8. 클라이언트 설정 관리

```go
// client/config.go
package main

import (
    "time"
)

type ClientConfig struct {
    ServerAddress   string
    Timeout         time.Duration
    MaxRetries      int
    EnableTLS       bool
    CertFile        string
    KeyFile         string
    ServerNameOverride string
    KeepAlive       KeepAliveConfig
}

type KeepAliveConfig struct {
    Time    time.Duration
    Timeout time.Duration
}

func DefaultConfig() *ClientConfig {
    return &ClientConfig{
        ServerAddress: "localhost:50051",
        Timeout:       30 * time.Second,
        MaxRetries:    3,
        EnableTLS:     false,
        KeepAlive: KeepAliveConfig{
            Time:    10 * time.Second,
            Timeout: 3 * time.Second,
        },
    }
}
```

## Best Practices

1. **연결 재사용**: 클라이언트 연결을 재사용하여 오버헤드 감소
2. **타임아웃 설정**: 모든 RPC 호출에 적절한 타임아웃 설정
3. **에러 처리**: gRPC status 코드를 활용한 체계적 에러 처리
4. **재시도 로직**: 일시적 실패에 대한 재시도 구현
5. **연결 모니터링**: 연결 상태 모니터링 및 자동 재연결
6. **로드 밸런싱**: 다중 서버 환경에서 로드 밸런싱
7. **보안**: 프로덕션 환경에서 TLS/mTLS 사용

## 실행 예제

```go
// client/example.go
package main

import (
    "log"
    pb "grpc-client/pb"
)

func main() {
    // 연결 매니저 생성
    cm, err := NewConnectionManager("localhost:50051")
    if err != nil {
        log.Fatalf("연결 매니저 생성 실패: %v", err)
    }
    defer cm.Close()
    
    // 클라이언트 생성
    client := pb.NewUserServiceClient(cm.GetConnection())
    
    // 각 RPC 패턴 실행
    log.Println("=== Unary RPC ===")
    runUnaryRPC(client)
    
    log.Println("\n=== Server Streaming RPC ===")
    runServerStreamingRPC(client)
    
    log.Println("\n=== Client Streaming RPC ===")
    runClientStreamingRPC(client)
    
    log.Println("\n=== Bidirectional Streaming RPC ===")
    runBidirectionalStreamingRPC(client)
}
```

## 다음 단계

클라이언트 구현을 마쳤다면:
1. 스트리밍 패턴 심화
2. 인터셉터와 미들웨어
3. 에러 처리 및 모니터링
4. 성능 최적화

## 참고 자료

- [gRPC Go Tutorial](https://grpc.io/docs/languages/go/basics/)
- [gRPC Client Best Practices](https://grpc.io/docs/guides/performance/)
- [gRPC Error Handling](https://grpc.io/docs/guides/error/)