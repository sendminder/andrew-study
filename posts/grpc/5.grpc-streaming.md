# gRPC ìŠ¤íŠ¸ë¦¬ë° ì™„ë²½ ë§ˆìŠ¤í„°

## ìŠ¤íŠ¸ë¦¬ë° ê°œìš”

gRPC ìŠ¤íŠ¸ë¦¬ë°ì€ ë‹¨ì¼ RPC í˜¸ì¶œë¡œ ì—¬ëŸ¬ ë©”ì‹œì§€ë¥¼ ì£¼ê³ ë°›ì„ ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ê¸°ëŠ¥ì…ë‹ˆë‹¤. HTTP/2ì˜ ìŠ¤íŠ¸ë¦¼ ë©€í‹°í”Œë ‰ì‹±ì„ í™œìš©í•˜ì—¬ íš¨ìœ¨ì ì¸ ì‹¤ì‹œê°„ í†µì‹ ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

## ìŠ¤íŠ¸ë¦¬ë° íŒ¨í„´ ë¹„êµ

| íŒ¨í„´ | ì„¤ëª… | ì‚¬ìš© ì‚¬ë¡€ |
|------|------|----------|
| **Unary** | ë‹¨ì¼ ìš”ì²­-ì‘ë‹µ | RESTì™€ ìœ ì‚¬í•œ API |
| **Server Streaming** | ë‹¨ì¼ ìš”ì²­, ë‹¤ì¤‘ ì‘ë‹µ | ëŒ€ìš©ëŸ‰ ë°ì´í„° ë‹¤ìš´ë¡œë“œ, ì‹¤ì‹œê°„ í”¼ë“œ |
| **Client Streaming** | ë‹¤ì¤‘ ìš”ì²­, ë‹¨ì¼ ì‘ë‹µ | íŒŒì¼ ì—…ë¡œë“œ, ë°ì´í„° ìˆ˜ì§‘ |
| **Bidirectional** | ë‹¤ì¤‘ ìš”ì²­-ì‘ë‹µ | ì±„íŒ…, ê²Œì„, í˜‘ì—… ë„êµ¬ |

## 1. Server Streaming RPC

### Proto ì •ì˜

```protobuf
// proto/streaming.proto
syntax = "proto3";

package streaming;
option go_package = "./pb";

import "google/protobuf/timestamp.proto";

service StreamingService {
  // Server streaming: ì‹¤ì‹œê°„ ì£¼ì‹ ê°€ê²©
  rpc GetStockPrices(StockRequest) returns (stream StockPrice);
  
  // Server streaming: ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°
  rpc StreamLogs(LogRequest) returns (stream LogEntry);
  
  // Server streaming: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì „ì†¡
  rpc DownloadFile(FileRequest) returns (stream FileChunk);
}

message StockRequest {
  repeated string symbols = 1;
  int32 interval_seconds = 2;
}

message StockPrice {
  string symbol = 1;
  double price = 2;
  double change = 3;
  int64 volume = 4;
  google.protobuf.Timestamp timestamp = 5;
}

message LogRequest {
  string service = 1;
  string level = 2;  // DEBUG, INFO, WARN, ERROR
  bool follow = 3;   // tail -f ì²˜ëŸ¼ ê³„ì† ìŠ¤íŠ¸ë¦¬ë°
}

message LogEntry {
  string service = 1;
  string level = 2;
  string message = 3;
  google.protobuf.Timestamp timestamp = 4;
  map<string, string> metadata = 5;
}

message FileRequest {
  string file_path = 1;
  int32 chunk_size = 2;
}

message FileChunk {
  bytes data = 1;
  int32 chunk_number = 2;
  bool is_last = 3;
}
```

### Server Streaming ì„œë²„ êµ¬í˜„

```go
// server/server_streaming.go
package main

import (
    "fmt"
    "io"
    "log"
    "math/rand"
    "os"
    "time"
    
    pb "streaming/pb"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "google.golang.org/protobuf/types/known/timestamppb"
)

type StreamingServer struct {
    pb.UnimplementedStreamingServiceServer
}

// GetStockPrices - ì‹¤ì‹œê°„ ì£¼ì‹ ê°€ê²© ìŠ¤íŠ¸ë¦¬ë°
func (s *StreamingServer) GetStockPrices(req *pb.StockRequest, stream pb.StreamingService_GetStockPricesServer) error {
    log.Printf("ì£¼ì‹ ê°€ê²© ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘: symbols=%v", req.Symbols)
    
    // ì´ˆê¸° ê°€ê²© ì„¤ì •
    prices := make(map[string]float64)
    for _, symbol := range req.Symbols {
        prices[symbol] = 100.0 + rand.Float64()*900.0
    }
    
    interval := time.Duration(req.IntervalSeconds) * time.Second
    if interval == 0 {
        interval = 1 * time.Second
    }
    
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-stream.Context().Done():
            log.Println("í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ")
            return nil
            
        case <-ticker.C:
            // ê° ì‹¬ë³¼ì— ëŒ€í•´ ê°€ê²© ì—…ë°ì´íŠ¸
            for _, symbol := range req.Symbols {
                // ëœë¤ ê°€ê²© ë³€ë™ (-5% ~ +5%)
                change := (rand.Float64() - 0.5) * 0.1
                prices[symbol] *= (1 + change)
                
                stockPrice := &pb.StockPrice{
                    Symbol:    symbol,
                    Price:     prices[symbol],
                    Change:    change * 100,
                    Volume:    int64(rand.Intn(1000000)),
                    Timestamp: timestamppb.Now(),
                }
                
                if err := stream.Send(stockPrice); err != nil {
                    return status.Errorf(codes.Internal, "ìŠ¤íŠ¸ë¦¼ ì „ì†¡ ì‹¤íŒ¨: %v", err)
                }
            }
        }
    }
}

// StreamLogs - ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°
func (s *StreamingServer) StreamLogs(req *pb.LogRequest, stream pb.StreamingService_StreamLogsServer) error {
    log.Printf("ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘: service=%s, level=%s", req.Service, req.Level)
    
    levels := []string{"DEBUG", "INFO", "WARN", "ERROR"}
    messages := []string{
        "ì„œë¹„ìŠ¤ ì‹œì‘ë¨",
        "ìš”ì²­ ì²˜ë¦¬ ì¤‘",
        "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°",
        "ìºì‹œ ì—…ë°ì´íŠ¸",
        "ì‚¬ìš©ì ì¸ì¦",
        "API í˜¸ì¶œ",
        "ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì‹¤í–‰",
    }
    
    // ê¸°ì¡´ ë¡œê·¸ ì „ì†¡
    for i := 0; i < 10; i++ {
        logEntry := &pb.LogEntry{
            Service:   req.Service,
            Level:     levels[rand.Intn(len(levels))],
            Message:   messages[rand.Intn(len(messages))],
            Timestamp: timestamppb.Now(),
            Metadata: map[string]string{
                "request_id": fmt.Sprintf("req_%d", i),
                "user_id":    fmt.Sprintf("user_%d", rand.Intn(100)),
            },
        }
        
        if err := stream.Send(logEntry); err != nil {
            return err
        }
        
        time.Sleep(100 * time.Millisecond)
    }
    
    // follow ëª¨ë“œ: ê³„ì† ìƒˆ ë¡œê·¸ ìƒì„±
    if req.Follow {
        ticker := time.NewTicker(2 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-stream.Context().Done():
                return nil
                
            case <-ticker.C:
                logEntry := &pb.LogEntry{
                    Service:   req.Service,
                    Level:     levels[rand.Intn(len(levels))],
                    Message:   fmt.Sprintf("ì‹¤ì‹œê°„ ë¡œê·¸: %s", messages[rand.Intn(len(messages))]),
                    Timestamp: timestamppb.Now(),
                    Metadata: map[string]string{
                        "request_id": fmt.Sprintf("req_%d", rand.Intn(1000)),
                    },
                }
                
                if err := stream.Send(logEntry); err != nil {
                    return err
                }
            }
        }
    }
    
    return nil
}

// DownloadFile - íŒŒì¼ ì²­í¬ ìŠ¤íŠ¸ë¦¬ë°
func (s *StreamingServer) DownloadFile(req *pb.FileRequest, stream pb.StreamingService_DownloadFileServer) error {
    log.Printf("íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œì‘: %s", req.FilePath)
    
    file, err := os.Open(req.FilePath)
    if err != nil {
        return status.Errorf(codes.NotFound, "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %v", err)
    }
    defer file.Close()
    
    chunkSize := req.ChunkSize
    if chunkSize == 0 {
        chunkSize = 1024 * 1024 // 1MB
    }
    
    buffer := make([]byte, chunkSize)
    chunkNumber := int32(0)
    
    for {
        n, err := file.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            return status.Errorf(codes.Internal, "íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: %v", err)
        }
        
        chunk := &pb.FileChunk{
            Data:        buffer[:n],
            ChunkNumber: chunkNumber,
            IsLast:      false,
        }
        
        if err := stream.Send(chunk); err != nil {
            return status.Errorf(codes.Internal, "ì²­í¬ ì „ì†¡ ì‹¤íŒ¨: %v", err)
        }
        
        chunkNumber++
    }
    
    // ë§ˆì§€ë§‰ ì²­í¬ í‘œì‹œ
    lastChunk := &pb.FileChunk{
        Data:        []byte{},
        ChunkNumber: chunkNumber,
        IsLast:      true,
    }
    
    return stream.Send(lastChunk)
}
```

### Server Streaming í´ë¼ì´ì–¸íŠ¸

```go
// client/server_streaming_client.go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "os"
    "time"
    
    pb "streaming/pb"
)

func consumeServerStream(client pb.StreamingServiceClient) {
    // 1. ì£¼ì‹ ê°€ê²© ìŠ¤íŠ¸ë¦¬ë°
    consumeStockPrices(client)
    
    // 2. ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°
    consumeLogs(client)
    
    // 3. íŒŒì¼ ë‹¤ìš´ë¡œë“œ
    downloadFile(client)
}

func consumeStockPrices(client pb.StreamingServiceClient) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    req := &pb.StockRequest{
        Symbols:         []string{"AAPL", "GOOGL", "MSFT"},
        IntervalSeconds: 2,
    }
    
    stream, err := client.GetStockPrices(ctx, req)
    if err != nil {
        log.Fatalf("ì£¼ì‹ ê°€ê²© ìŠ¤íŠ¸ë¦¼ ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    
    for {
        price, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf("ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹  ì‹¤íŒ¨: %v", err)
        }
        
        log.Printf("ğŸ“ˆ %s: $%.2f (%.2f%%) Vol: %d",
            price.Symbol, price.Price, price.Change, price.Volume)
    }
}

func consumeLogs(client pb.StreamingServiceClient) {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    req := &pb.LogRequest{
        Service: "api-gateway",
        Level:   "INFO",
        Follow:  true,
    }
    
    stream, err := client.StreamLogs(ctx, req)
    if err != nil {
        log.Fatalf("ë¡œê·¸ ìŠ¤íŠ¸ë¦¼ ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    
    // 10ê°œ ë¡œê·¸ë§Œ ë°›ê³  ì¢…ë£Œ
    count := 0
    for {
        logEntry, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf("ë¡œê·¸ ìˆ˜ì‹  ì‹¤íŒ¨: %v", err)
        }
        
        log.Printf("[%s] %s: %s", logEntry.Level, logEntry.Service, logEntry.Message)
        
        count++
        if count >= 10 {
            cancel() // ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
            break
        }
    }
}

func downloadFile(client pb.StreamingServiceClient) {
    ctx := context.Background()
    
    req := &pb.FileRequest{
        FilePath:  "/path/to/large/file.dat",
        ChunkSize: 1024 * 1024, // 1MB chunks
    }
    
    stream, err := client.DownloadFile(ctx, req)
    if err != nil {
        log.Fatalf("íŒŒì¼ ë‹¤ìš´ë¡œë“œ ìŠ¤íŠ¸ë¦¼ ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    
    // ë¡œì»¬ íŒŒì¼ë¡œ ì €ì¥
    outputFile, err := os.Create("downloaded_file.dat")
    if err != nil {
        log.Fatalf("ì¶œë ¥ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    defer outputFile.Close()
    
    totalBytes := 0
    for {
        chunk, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf("ì²­í¬ ìˆ˜ì‹  ì‹¤íŒ¨: %v", err)
        }
        
        if !chunk.IsLast {
            n, err := outputFile.Write(chunk.Data)
            if err != nil {
                log.Fatalf("íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨: %v", err)
            }
            totalBytes += n
            
            log.Printf("ì²­í¬ #%d ìˆ˜ì‹ : %d bytes (ì´ %d bytes)",
                chunk.ChunkNumber, len(chunk.Data), totalBytes)
        }
    }
    
    log.Printf("íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: %d bytes", totalBytes)
}
```

## 2. Client Streaming RPC

### Proto ì •ì˜

```protobuf
service StreamingService {
  // Client streaming: íŒŒì¼ ì—…ë¡œë“œ
  rpc UploadFile(stream FileChunk) returns (UploadResult);
  
  // Client streaming: ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘
  rpc CollectSensorData(stream SensorData) returns (SensorSummary);
  
  // Client streaming: ë°°ì¹˜ ì²˜ë¦¬
  rpc ProcessBatch(stream BatchItem) returns (BatchResult);
}

message UploadResult {
  string file_id = 1;
  int64 total_bytes = 2;
  string checksum = 3;
  google.protobuf.Timestamp uploaded_at = 4;
}

message SensorData {
  string sensor_id = 1;
  double temperature = 2;
  double humidity = 3;
  double pressure = 4;
  google.protobuf.Timestamp timestamp = 5;
}

message SensorSummary {
  int32 total_readings = 1;
  double avg_temperature = 2;
  double avg_humidity = 3;
  double avg_pressure = 4;
  google.protobuf.Timestamp start_time = 5;
  google.protobuf.Timestamp end_time = 6;
}

message BatchItem {
  string id = 1;
  string type = 2;
  bytes data = 3;
}

message BatchResult {
  int32 processed_count = 1;
  int32 success_count = 2;
  int32 failed_count = 3;
  repeated string failed_ids = 4;
}
```

### Client Streaming ì„œë²„ êµ¬í˜„

```go
// server/client_streaming.go
package main

import (
    "crypto/md5"
    "fmt"
    "io"
    "log"
    
    pb "streaming/pb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

// UploadFile - í´ë¼ì´ì–¸íŠ¸ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ íŒŒì¼ ì—…ë¡œë“œ
func (s *StreamingServer) UploadFile(stream pb.StreamingService_UploadFileServer) error {
    log.Println("íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘")
    
    var fileData []byte
    chunkCount := 0
    
    for {
        chunk, err := stream.Recv()
        if err == io.EOF {
            // ì—…ë¡œë“œ ì™„ë£Œ
            checksum := fmt.Sprintf("%x", md5.Sum(fileData))
            
            result := &pb.UploadResult{
                FileId:     fmt.Sprintf("file_%d", time.Now().Unix()),
                TotalBytes: int64(len(fileData)),
                Checksum:   checksum,
                UploadedAt: timestamppb.Now(),
            }
            
            log.Printf("íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: %d chunks, %d bytes", chunkCount, len(fileData))
            return stream.SendAndClose(result)
        }
        if err != nil {
            return err
        }
        
        fileData = append(fileData, chunk.Data...)
        chunkCount++
        
        log.Printf("ì²­í¬ #%d ìˆ˜ì‹ : %d bytes", chunk.ChunkNumber, len(chunk.Data))
    }
}

// CollectSensorData - ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘ ë° ì§‘ê³„
func (s *StreamingServer) CollectSensorData(stream pb.StreamingService_CollectSensorDataServer) error {
    log.Println("ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘")
    
    var (
        totalReadings   int32
        sumTemperature  float64
        sumHumidity     float64
        sumPressure     float64
        startTime       *timestamppb.Timestamp
        endTime         *timestamppb.Timestamp
    )
    
    for {
        data, err := stream.Recv()
        if err == io.EOF {
            // ì§‘ê³„ ê²°ê³¼ ë°˜í™˜
            summary := &pb.SensorSummary{
                TotalReadings:  totalReadings,
                AvgTemperature: sumTemperature / float64(totalReadings),
                AvgHumidity:    sumHumidity / float64(totalReadings),
                AvgPressure:    sumPressure / float64(totalReadings),
                StartTime:      startTime,
                EndTime:        endTime,
            }
            
            log.Printf("ì„¼ì„œ ë°ì´í„° ì§‘ê³„ ì™„ë£Œ: %d readings", totalReadings)
            return stream.SendAndClose(summary)
        }
        if err != nil {
            return err
        }
        
        // ì²« ë²ˆì§¸ íƒ€ì„ìŠ¤íƒ¬í”„ ì €ì¥
        if startTime == nil {
            startTime = data.Timestamp
        }
        endTime = data.Timestamp
        
        // ë°ì´í„° ì§‘ê³„
        totalReadings++
        sumTemperature += data.Temperature
        sumHumidity += data.Humidity
        sumPressure += data.Pressure
        
        log.Printf("ì„¼ì„œ ë°ì´í„° ìˆ˜ì‹ : ID=%s, Temp=%.2fÂ°C",
            data.SensorId, data.Temperature)
    }
}

// ProcessBatch - ë°°ì¹˜ ì•„ì´í…œ ì²˜ë¦¬
func (s *StreamingServer) ProcessBatch(stream pb.StreamingService_ProcessBatchServer) error {
    log.Println("ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘")
    
    var (
        processedCount int32
        successCount   int32
        failedCount    int32
        failedIDs      []string
    )
    
    for {
        item, err := stream.Recv()
        if err == io.EOF {
            result := &pb.BatchResult{
                ProcessedCount: processedCount,
                SuccessCount:   successCount,
                FailedCount:    failedCount,
                FailedIds:      failedIDs,
            }
            
            log.Printf("ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ: %d processed, %d success, %d failed",
                processedCount, successCount, failedCount)
            return stream.SendAndClose(result)
        }
        if err != nil {
            return err
        }
        
        processedCount++
        
        // ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜ (10% ì‹¤íŒ¨ìœ¨)
        if rand.Float32() < 0.1 {
            failedCount++
            failedIDs = append(failedIDs, item.Id)
            log.Printf("ë°°ì¹˜ ì•„ì´í…œ ì²˜ë¦¬ ì‹¤íŒ¨: ID=%s", item.Id)
        } else {
            successCount++
            log.Printf("ë°°ì¹˜ ì•„ì´í…œ ì²˜ë¦¬ ì„±ê³µ: ID=%s, Type=%s", item.Id, item.Type)
        }
    }
}
```

## 3. Bidirectional Streaming RPC

### Proto ì •ì˜

```protobuf
service StreamingService {
  // Bidirectional: ì±„íŒ…
  rpc Chat(stream ChatMessage) returns (stream ChatMessage);
  
  // Bidirectional: ì‹¤ì‹œê°„ ê²Œì„
  rpc GameSession(stream GameAction) returns (stream GameState);
  
  // Bidirectional: í˜‘ì—… í¸ì§‘
  rpc CollaborativeEdit(stream EditOperation) returns (stream DocumentUpdate);
}

message ChatMessage {
  string user_id = 1;
  string room_id = 2;
  string message = 3;
  google.protobuf.Timestamp timestamp = 4;
}

message GameAction {
  string player_id = 1;
  string action_type = 2;  // MOVE, ATTACK, DEFEND
  map<string, string> parameters = 3;
}

message GameState {
  map<string, PlayerState> players = 1;
  string game_status = 2;  // ONGOING, PAUSED, FINISHED
  google.protobuf.Timestamp timestamp = 3;
}

message PlayerState {
  string player_id = 1;
  int32 health = 2;
  int32 score = 3;
  string position = 4;
}

message EditOperation {
  string user_id = 1;
  string document_id = 2;
  string operation_type = 3;  // INSERT, DELETE, FORMAT
  int32 position = 4;
  string content = 5;
}

message DocumentUpdate {
  string document_id = 1;
  string user_id = 2;
  string content = 3;
  repeated string active_users = 4;
  google.protobuf.Timestamp timestamp = 5;
}
```

### Bidirectional Streaming ì„œë²„ êµ¬í˜„

```go
// server/bidirectional_streaming.go
package main

import (
    "fmt"
    "io"
    "log"
    "sync"
    
    pb "streaming/pb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

// Chat - ì–‘ë°©í–¥ ì±„íŒ…
func (s *StreamingServer) Chat(stream pb.StreamingService_ChatServer) error {
    log.Println("ì±„íŒ… ì„¸ì…˜ ì‹œì‘")
    
    // ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¥¼ ìœ„í•œ ì±„ë„
    messageChan := make(chan *pb.ChatMessage, 100)
    defer close(messageChan)
    
    // ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ê³ ë£¨í‹´
    go func() {
        for msg := range messageChan {
            // ì—ì½” ë©”ì‹œì§€ ìƒì„±
            response := &pb.ChatMessage{
                UserId:    "Server",
                RoomId:    msg.RoomId,
                Message:   fmt.Sprintf("Echo: %s", msg.Message),
                Timestamp: timestamppb.Now(),
            }
            
            if err := stream.Send(response); err != nil {
                log.Printf("ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: %v", err)
                return
            }
        }
    }()
    
    // í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ìˆ˜ì‹ 
    for {
        msg, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        log.Printf("ì±„íŒ… ë©”ì‹œì§€ ìˆ˜ì‹ : [%s] %s: %s",
            msg.RoomId, msg.UserId, msg.Message)
        
        // ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        select {
        case messageChan <- msg:
        default:
            log.Println("ë©”ì‹œì§€ ì±„ë„ì´ ê°€ë“ ì°¸")
        }
    }
}

// GameSession - ì‹¤ì‹œê°„ ê²Œì„ ì„¸ì…˜
func (s *StreamingServer) GameSession(stream pb.StreamingService_GameSessionServer) error {
    log.Println("ê²Œì„ ì„¸ì…˜ ì‹œì‘")
    
    // ê²Œì„ ìƒíƒœ ê´€ë¦¬
    gameState := &GameState{
        players: make(map[string]*pb.PlayerState),
        mu:      sync.RWMutex{},
    }
    
    // ìƒíƒœ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    updateChan := make(chan bool, 100)
    defer close(updateChan)
    
    go func() {
        for range updateChan {
            gameState.mu.RLock()
            state := &pb.GameState{
                Players:    gameState.players,
                GameStatus: "ONGOING",
                Timestamp:  timestamppb.Now(),
            }
            gameState.mu.RUnlock()
            
            if err := stream.Send(state); err != nil {
                log.Printf("ê²Œì„ ìƒíƒœ ì „ì†¡ ì‹¤íŒ¨: %v", err)
                return
            }
        }
    }()
    
    for {
        action, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        log.Printf("ê²Œì„ ì•¡ì…˜: Player=%s, Type=%s",
            action.PlayerId, action.ActionType)
        
        // ê²Œì„ ë¡œì§ ì²˜ë¦¬
        gameState.mu.Lock()
        player, exists := gameState.players[action.PlayerId]
        if !exists {
            player = &pb.PlayerState{
                PlayerId: action.PlayerId,
                Health:   100,
                Score:    0,
                Position: "0,0",
            }
            gameState.players[action.PlayerId] = player
        }
        
        switch action.ActionType {
        case "MOVE":
            if pos, ok := action.Parameters["position"]; ok {
                player.Position = pos
            }
        case "ATTACK":
            player.Score += 10
        case "DEFEND":
            player.Health = min(player.Health+5, 100)
        }
        gameState.mu.Unlock()
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°
        select {
        case updateChan <- true:
        default:
        }
    }
}

type GameState struct {
    players map[string]*pb.PlayerState
    mu      sync.RWMutex
}

func min(a, b int32) int32 {
    if a < b {
        return a
    }
    return b
}
```

## 4. ìŠ¤íŠ¸ë¦¬ë° ìµœì í™”

### í”Œë¡œìš° ì»¨íŠ¸ë¡¤

```go
// server/flow_control.go
package main

import (
    "context"
    "time"
    
    pb "streaming/pb"
)

// í”Œë¡œìš° ì»¨íŠ¸ë¡¤ì´ ì ìš©ëœ ìŠ¤íŠ¸ë¦¬ë°
func (s *StreamingServer) ControlledStream(req *pb.StreamRequest, stream pb.StreamingService_ControlledStreamServer) error {
    // ë°±í”„ë ˆì…” ì²˜ë¦¬
    semaphore := make(chan struct{}, 10) // ìµœëŒ€ 10ê°œ ë™ì‹œ ì²˜ë¦¬
    
    for i := 0; i < 100; i++ {
        select {
        case semaphore <- struct{}{}:
            go func(index int) {
                defer func() { <-semaphore }()
                
                // ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
                time.Sleep(100 * time.Millisecond)
                
                data := &pb.StreamData{
                    Id:   index,
                    Data: fmt.Sprintf("Data %d", index),
                }
                
                if err := stream.Send(data); err != nil {
                    log.Printf("ì „ì†¡ ì‹¤íŒ¨: %v", err)
                }
            }(i)
            
        case <-stream.Context().Done():
            return stream.Context().Err()
        }
    }
    
    // ëª¨ë“  ê³ ë£¨í‹´ ì™„ë£Œ ëŒ€ê¸°
    for i := 0; i < cap(semaphore); i++ {
        semaphore <- struct{}{}
    }
    
    return nil
}
```

### ì—ëŸ¬ ì²˜ë¦¬ì™€ ì¬ì—°ê²°

```go
// client/resilient_streaming.go
package main

import (
    "context"
    "io"
    "time"
    
    pb "streaming/pb"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// ì¬ì—°ê²°ì´ ê°€ëŠ¥í•œ ìŠ¤íŠ¸ë¦¬ë° í´ë¼ì´ì–¸íŠ¸
type ResilientStreamClient struct {
    client pb.StreamingServiceClient
    lastID int32
}

func (r *ResilientStreamClient) ConsumeStreamWithRetry(ctx context.Context) {
    retryCount := 0
    maxRetries := 5
    
    for retryCount < maxRetries {
        err := r.consumeStream(ctx)
        
        if err == nil {
            return // ì •ìƒ ì¢…ë£Œ
        }
        
        if st, ok := status.FromError(err); ok {
            switch st.Code() {
            case codes.Unavailable, codes.DeadlineExceeded:
                // ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬
                retryCount++
                backoff := time.Duration(retryCount) * time.Second
                log.Printf("ì¬ì—°ê²° ì‹œë„ %d/%d (ëŒ€ê¸°: %v)", retryCount, maxRetries, backoff)
                time.Sleep(backoff)
                continue
                
            default:
                // ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬
                log.Printf("ìŠ¤íŠ¸ë¦¼ ì—ëŸ¬: %v", err)
                return
            }
        }
    }
    
    log.Printf("ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼")
}

func (r *ResilientStreamClient) consumeStream(ctx context.Context) error {
    req := &pb.StreamRequest{
        StartFromId: r.lastID, // ë§ˆì§€ë§‰ ìˆ˜ì‹  IDë¶€í„° ì¬ê°œ
    }
    
    stream, err := r.client.GetDataStream(ctx, req)
    if err != nil {
        return err
    }
    
    for {
        data, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        // ë§ˆì§€ë§‰ ìˆ˜ì‹  ID ì—…ë°ì´íŠ¸
        r.lastID = data.Id
        
        log.Printf("ë°ì´í„° ìˆ˜ì‹ : ID=%d, Data=%s", data.Id, data.Data)
    }
}
```

## 5. ì„±ëŠ¥ ìµœì í™” íŒ

### ë²„í¼ë§ê³¼ ë°°ì¹˜ ì²˜ë¦¬

```go
// server/buffered_streaming.go
package main

import (
    "time"
    
    pb "streaming/pb"
)

// ë²„í¼ë§ëœ ìŠ¤íŠ¸ë¦¬ë°
func (s *StreamingServer) BufferedStream(req *pb.StreamRequest, stream pb.StreamingService_BufferedStreamServer) error {
    buffer := make([]*pb.StreamData, 0, 100)
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    dataChan := make(chan *pb.StreamData, 1000)
    
    // ë°ì´í„° ìƒì„± ê³ ë£¨í‹´
    go func() {
        for i := 0; i < 1000; i++ {
            dataChan <- &pb.StreamData{
                Id:   int32(i),
                Data: fmt.Sprintf("Data %d", i),
            }
            time.Sleep(10 * time.Millisecond)
        }
        close(dataChan)
    }()
    
    for {
        select {
        case data, ok := <-dataChan:
            if !ok {
                // ë‚¨ì€ ë²„í¼ ì „ì†¡
                if len(buffer) > 0 {
                    for _, item := range buffer {
                        if err := stream.Send(item); err != nil {
                            return err
                        }
                    }
                }
                return nil
            }
            
            buffer = append(buffer, data)
            
            // ë²„í¼ê°€ ê°€ë“ ì°¨ë©´ ì „ì†¡
            if len(buffer) >= 100 {
                for _, item := range buffer {
                    if err := stream.Send(item); err != nil {
                        return err
                    }
                }
                buffer = buffer[:0]
            }
            
        case <-ticker.C:
            // ì£¼ê¸°ì ìœ¼ë¡œ ë²„í¼ í”ŒëŸ¬ì‹œ
            if len(buffer) > 0 {
                for _, item := range buffer {
                    if err := stream.Send(item); err != nil {
                        return err
                    }
                }
                buffer = buffer[:0]
            }
            
        case <-stream.Context().Done():
            return stream.Context().Err()
        }
    }
}
```

## Best Practices

1. **ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©**: íƒ€ì„ì•„ì›ƒê³¼ ì·¨ì†Œ ì²˜ë¦¬
2. **ì—ëŸ¬ ì²˜ë¦¬**: ìŠ¤íŠ¸ë¦¼ë³„ ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬
3. **í”Œë¡œìš° ì»¨íŠ¸ë¡¤**: ë°±í”„ë ˆì…” êµ¬í˜„
4. **ë¦¬ì†ŒìŠ¤ ê´€ë¦¬**: ê³ ë£¨í‹´ê³¼ ì±„ë„ ì ì ˆíˆ ê´€ë¦¬
5. **ì¬ì—°ê²° ë¡œì§**: ë„¤íŠ¸ì›Œí¬ ì¥ì•  ëŒ€ì‘
6. **ë²„í¼ë§**: íš¨ìœ¨ì ì¸ ë°ì´í„° ì „ì†¡
7. **ëª¨ë‹ˆí„°ë§**: ìŠ¤íŠ¸ë¦¼ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

## ë‹¤ìŒ ë‹¨ê³„

ìŠ¤íŠ¸ë¦¬ë°ì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:
1. ì¸í„°ì…‰í„°ì™€ ë¯¸ë“¤ì›¨ì–´
2. ì—ëŸ¬ ì²˜ë¦¬ ë° ëª¨ë‹ˆí„°ë§
3. ì„±ëŠ¥ ìµœì í™”
4. í”„ë¡œë•ì…˜ ë°°í¬

## ì°¸ê³  ìë£Œ

- [gRPC Streaming Concepts](https://grpc.io/docs/what-is-grpc/core-concepts/#streaming)
- [gRPC Go Streaming](https://grpc.io/docs/languages/go/basics/#streaming-rpcs)
- [HTTP/2 Streams](https://http2.github.io/http2-spec/#StreamsLayer)