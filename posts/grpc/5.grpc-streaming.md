# gRPC 스트리밍 완벽 마스터

## 스트리밍 개요

gRPC 스트리밍은 단일 RPC 호출로 여러 메시지를 주고받을 수 있는 강력한 기능입니다. HTTP/2의 스트림 멀티플렉싱을 활용하여 효율적인 실시간 통신을 구현합니다.

## 스트리밍 패턴 비교

| 패턴 | 설명 | 사용 사례 |
|------|------|----------|
| **Unary** | 단일 요청-응답 | REST와 유사한 API |
| **Server Streaming** | 단일 요청, 다중 응답 | 대용량 데이터 다운로드, 실시간 피드 |
| **Client Streaming** | 다중 요청, 단일 응답 | 파일 업로드, 데이터 수집 |
| **Bidirectional** | 다중 요청-응답 | 채팅, 게임, 협업 도구 |

## 1. Server Streaming RPC

### Proto 정의

```protobuf
// proto/streaming.proto
syntax = "proto3";

package streaming;
option go_package = "./pb";

import "google/protobuf/timestamp.proto";

service StreamingService {
  // Server streaming: 실시간 주식 가격
  rpc GetStockPrices(StockRequest) returns (stream StockPrice);
  
  // Server streaming: 로그 스트리밍
  rpc StreamLogs(LogRequest) returns (stream LogEntry);
  
  // Server streaming: 대용량 데이터 전송
  rpc DownloadFile(FileRequest) returns (stream FileChunk);
}

message StockRequest {
  repeated string symbols = 1;
  int32 interval_seconds = 2;
}

message StockPrice {
  string symbol = 1;
  double price = 2;
  double change = 3;
  int64 volume = 4;
  google.protobuf.Timestamp timestamp = 5;
}

message LogRequest {
  string service = 1;
  string level = 2;  // DEBUG, INFO, WARN, ERROR
  bool follow = 3;   // tail -f 처럼 계속 스트리밍
}

message LogEntry {
  string service = 1;
  string level = 2;
  string message = 3;
  google.protobuf.Timestamp timestamp = 4;
  map<string, string> metadata = 5;
}

message FileRequest {
  string file_path = 1;
  int32 chunk_size = 2;
}

message FileChunk {
  bytes data = 1;
  int32 chunk_number = 2;
  bool is_last = 3;
}
```

### Server Streaming 서버 구현

```go
// server/server_streaming.go
package main

import (
    "fmt"
    "io"
    "log"
    "math/rand"
    "os"
    "time"
    
    pb "streaming/pb"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "google.golang.org/protobuf/types/known/timestamppb"
)

type StreamingServer struct {
    pb.UnimplementedStreamingServiceServer
}

// GetStockPrices - 실시간 주식 가격 스트리밍
func (s *StreamingServer) GetStockPrices(req *pb.StockRequest, stream pb.StreamingService_GetStockPricesServer) error {
    log.Printf("주식 가격 스트리밍 시작: symbols=%v", req.Symbols)
    
    // 초기 가격 설정
    prices := make(map[string]float64)
    for _, symbol := range req.Symbols {
        prices[symbol] = 100.0 + rand.Float64()*900.0
    }
    
    interval := time.Duration(req.IntervalSeconds) * time.Second
    if interval == 0 {
        interval = 1 * time.Second
    }
    
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-stream.Context().Done():
            log.Println("클라이언트 연결 종료")
            return nil
            
        case <-ticker.C:
            // 각 심볼에 대해 가격 업데이트
            for _, symbol := range req.Symbols {
                // 랜덤 가격 변동 (-5% ~ +5%)
                change := (rand.Float64() - 0.5) * 0.1
                prices[symbol] *= (1 + change)
                
                stockPrice := &pb.StockPrice{
                    Symbol:    symbol,
                    Price:     prices[symbol],
                    Change:    change * 100,
                    Volume:    int64(rand.Intn(1000000)),
                    Timestamp: timestamppb.Now(),
                }
                
                if err := stream.Send(stockPrice); err != nil {
                    return status.Errorf(codes.Internal, "스트림 전송 실패: %v", err)
                }
            }
        }
    }
}

// StreamLogs - 로그 스트리밍
func (s *StreamingServer) StreamLogs(req *pb.LogRequest, stream pb.StreamingService_StreamLogsServer) error {
    log.Printf("로그 스트리밍 시작: service=%s, level=%s", req.Service, req.Level)
    
    levels := []string{"DEBUG", "INFO", "WARN", "ERROR"}
    messages := []string{
        "서비스 시작됨",
        "요청 처리 중",
        "데이터베이스 연결",
        "캐시 업데이트",
        "사용자 인증",
        "API 호출",
        "백그라운드 작업 실행",
    }
    
    // 기존 로그 전송
    for i := 0; i < 10; i++ {
        logEntry := &pb.LogEntry{
            Service:   req.Service,
            Level:     levels[rand.Intn(len(levels))],
            Message:   messages[rand.Intn(len(messages))],
            Timestamp: timestamppb.Now(),
            Metadata: map[string]string{
                "request_id": fmt.Sprintf("req_%d", i),
                "user_id":    fmt.Sprintf("user_%d", rand.Intn(100)),
            },
        }
        
        if err := stream.Send(logEntry); err != nil {
            return err
        }
        
        time.Sleep(100 * time.Millisecond)
    }
    
    // follow 모드: 계속 새 로그 생성
    if req.Follow {
        ticker := time.NewTicker(2 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-stream.Context().Done():
                return nil
                
            case <-ticker.C:
                logEntry := &pb.LogEntry{
                    Service:   req.Service,
                    Level:     levels[rand.Intn(len(levels))],
                    Message:   fmt.Sprintf("실시간 로그: %s", messages[rand.Intn(len(messages))]),
                    Timestamp: timestamppb.Now(),
                    Metadata: map[string]string{
                        "request_id": fmt.Sprintf("req_%d", rand.Intn(1000)),
                    },
                }
                
                if err := stream.Send(logEntry); err != nil {
                    return err
                }
            }
        }
    }
    
    return nil
}

// DownloadFile - 파일 청크 스트리밍
func (s *StreamingServer) DownloadFile(req *pb.FileRequest, stream pb.StreamingService_DownloadFileServer) error {
    log.Printf("파일 다운로드 시작: %s", req.FilePath)
    
    file, err := os.Open(req.FilePath)
    if err != nil {
        return status.Errorf(codes.NotFound, "파일을 찾을 수 없습니다: %v", err)
    }
    defer file.Close()
    
    chunkSize := req.ChunkSize
    if chunkSize == 0 {
        chunkSize = 1024 * 1024 // 1MB
    }
    
    buffer := make([]byte, chunkSize)
    chunkNumber := int32(0)
    
    for {
        n, err := file.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            return status.Errorf(codes.Internal, "파일 읽기 실패: %v", err)
        }
        
        chunk := &pb.FileChunk{
            Data:        buffer[:n],
            ChunkNumber: chunkNumber,
            IsLast:      false,
        }
        
        if err := stream.Send(chunk); err != nil {
            return status.Errorf(codes.Internal, "청크 전송 실패: %v", err)
        }
        
        chunkNumber++
    }
    
    // 마지막 청크 표시
    lastChunk := &pb.FileChunk{
        Data:        []byte{},
        ChunkNumber: chunkNumber,
        IsLast:      true,
    }
    
    return stream.Send(lastChunk)
}
```

### Server Streaming 클라이언트

```go
// client/server_streaming_client.go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "os"
    "time"
    
    pb "streaming/pb"
)

func consumeServerStream(client pb.StreamingServiceClient) {
    // 1. 주식 가격 스트리밍
    consumeStockPrices(client)
    
    // 2. 로그 스트리밍
    consumeLogs(client)
    
    // 3. 파일 다운로드
    downloadFile(client)
}

func consumeStockPrices(client pb.StreamingServiceClient) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    req := &pb.StockRequest{
        Symbols:         []string{"AAPL", "GOOGL", "MSFT"},
        IntervalSeconds: 2,
    }
    
    stream, err := client.GetStockPrices(ctx, req)
    if err != nil {
        log.Fatalf("주식 가격 스트림 생성 실패: %v", err)
    }
    
    for {
        price, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf("스트림 수신 실패: %v", err)
        }
        
        log.Printf("📈 %s: $%.2f (%.2f%%) Vol: %d",
            price.Symbol, price.Price, price.Change, price.Volume)
    }
}

func consumeLogs(client pb.StreamingServiceClient) {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    req := &pb.LogRequest{
        Service: "api-gateway",
        Level:   "INFO",
        Follow:  true,
    }
    
    stream, err := client.StreamLogs(ctx, req)
    if err != nil {
        log.Fatalf("로그 스트림 생성 실패: %v", err)
    }
    
    // 10개 로그만 받고 종료
    count := 0
    for {
        logEntry, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf("로그 수신 실패: %v", err)
        }
        
        log.Printf("[%s] %s: %s", logEntry.Level, logEntry.Service, logEntry.Message)
        
        count++
        if count >= 10 {
            cancel() // 스트림 종료
            break
        }
    }
}

func downloadFile(client pb.StreamingServiceClient) {
    ctx := context.Background()
    
    req := &pb.FileRequest{
        FilePath:  "/path/to/large/file.dat",
        ChunkSize: 1024 * 1024, // 1MB chunks
    }
    
    stream, err := client.DownloadFile(ctx, req)
    if err != nil {
        log.Fatalf("파일 다운로드 스트림 생성 실패: %v", err)
    }
    
    // 로컬 파일로 저장
    outputFile, err := os.Create("downloaded_file.dat")
    if err != nil {
        log.Fatalf("출력 파일 생성 실패: %v", err)
    }
    defer outputFile.Close()
    
    totalBytes := 0
    for {
        chunk, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf("청크 수신 실패: %v", err)
        }
        
        if !chunk.IsLast {
            n, err := outputFile.Write(chunk.Data)
            if err != nil {
                log.Fatalf("파일 쓰기 실패: %v", err)
            }
            totalBytes += n
            
            log.Printf("청크 #%d 수신: %d bytes (총 %d bytes)",
                chunk.ChunkNumber, len(chunk.Data), totalBytes)
        }
    }
    
    log.Printf("파일 다운로드 완료: %d bytes", totalBytes)
}
```

## 2. Client Streaming RPC

### Proto 정의

```protobuf
service StreamingService {
  // Client streaming: 파일 업로드
  rpc UploadFile(stream FileChunk) returns (UploadResult);
  
  // Client streaming: 센서 데이터 수집
  rpc CollectSensorData(stream SensorData) returns (SensorSummary);
  
  // Client streaming: 배치 처리
  rpc ProcessBatch(stream BatchItem) returns (BatchResult);
}

message UploadResult {
  string file_id = 1;
  int64 total_bytes = 2;
  string checksum = 3;
  google.protobuf.Timestamp uploaded_at = 4;
}

message SensorData {
  string sensor_id = 1;
  double temperature = 2;
  double humidity = 3;
  double pressure = 4;
  google.protobuf.Timestamp timestamp = 5;
}

message SensorSummary {
  int32 total_readings = 1;
  double avg_temperature = 2;
  double avg_humidity = 3;
  double avg_pressure = 4;
  google.protobuf.Timestamp start_time = 5;
  google.protobuf.Timestamp end_time = 6;
}

message BatchItem {
  string id = 1;
  string type = 2;
  bytes data = 3;
}

message BatchResult {
  int32 processed_count = 1;
  int32 success_count = 2;
  int32 failed_count = 3;
  repeated string failed_ids = 4;
}
```

### Client Streaming 서버 구현

```go
// server/client_streaming.go
package main

import (
    "crypto/md5"
    "fmt"
    "io"
    "log"
    
    pb "streaming/pb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

// UploadFile - 클라이언트 스트리밍으로 파일 업로드
func (s *StreamingServer) UploadFile(stream pb.StreamingService_UploadFileServer) error {
    log.Println("파일 업로드 시작")
    
    var fileData []byte
    chunkCount := 0
    
    for {
        chunk, err := stream.Recv()
        if err == io.EOF {
            // 업로드 완료
            checksum := fmt.Sprintf("%x", md5.Sum(fileData))
            
            result := &pb.UploadResult{
                FileId:     fmt.Sprintf("file_%d", time.Now().Unix()),
                TotalBytes: int64(len(fileData)),
                Checksum:   checksum,
                UploadedAt: timestamppb.Now(),
            }
            
            log.Printf("파일 업로드 완료: %d chunks, %d bytes", chunkCount, len(fileData))
            return stream.SendAndClose(result)
        }
        if err != nil {
            return err
        }
        
        fileData = append(fileData, chunk.Data...)
        chunkCount++
        
        log.Printf("청크 #%d 수신: %d bytes", chunk.ChunkNumber, len(chunk.Data))
    }
}

// CollectSensorData - 센서 데이터 수집 및 집계
func (s *StreamingServer) CollectSensorData(stream pb.StreamingService_CollectSensorDataServer) error {
    log.Println("센서 데이터 수집 시작")
    
    var (
        totalReadings   int32
        sumTemperature  float64
        sumHumidity     float64
        sumPressure     float64
        startTime       *timestamppb.Timestamp
        endTime         *timestamppb.Timestamp
    )
    
    for {
        data, err := stream.Recv()
        if err == io.EOF {
            // 집계 결과 반환
            summary := &pb.SensorSummary{
                TotalReadings:  totalReadings,
                AvgTemperature: sumTemperature / float64(totalReadings),
                AvgHumidity:    sumHumidity / float64(totalReadings),
                AvgPressure:    sumPressure / float64(totalReadings),
                StartTime:      startTime,
                EndTime:        endTime,
            }
            
            log.Printf("센서 데이터 집계 완료: %d readings", totalReadings)
            return stream.SendAndClose(summary)
        }
        if err != nil {
            return err
        }
        
        // 첫 번째 타임스탬프 저장
        if startTime == nil {
            startTime = data.Timestamp
        }
        endTime = data.Timestamp
        
        // 데이터 집계
        totalReadings++
        sumTemperature += data.Temperature
        sumHumidity += data.Humidity
        sumPressure += data.Pressure
        
        log.Printf("센서 데이터 수신: ID=%s, Temp=%.2f°C",
            data.SensorId, data.Temperature)
    }
}

// ProcessBatch - 배치 아이템 처리
func (s *StreamingServer) ProcessBatch(stream pb.StreamingService_ProcessBatchServer) error {
    log.Println("배치 처리 시작")
    
    var (
        processedCount int32
        successCount   int32
        failedCount    int32
        failedIDs      []string
    )
    
    for {
        item, err := stream.Recv()
        if err == io.EOF {
            result := &pb.BatchResult{
                ProcessedCount: processedCount,
                SuccessCount:   successCount,
                FailedCount:    failedCount,
                FailedIds:      failedIDs,
            }
            
            log.Printf("배치 처리 완료: %d processed, %d success, %d failed",
                processedCount, successCount, failedCount)
            return stream.SendAndClose(result)
        }
        if err != nil {
            return err
        }
        
        processedCount++
        
        // 처리 시뮬레이션 (10% 실패율)
        if rand.Float32() < 0.1 {
            failedCount++
            failedIDs = append(failedIDs, item.Id)
            log.Printf("배치 아이템 처리 실패: ID=%s", item.Id)
        } else {
            successCount++
            log.Printf("배치 아이템 처리 성공: ID=%s, Type=%s", item.Id, item.Type)
        }
    }
}
```

## 3. Bidirectional Streaming RPC

### Proto 정의

```protobuf
service StreamingService {
  // Bidirectional: 채팅
  rpc Chat(stream ChatMessage) returns (stream ChatMessage);
  
  // Bidirectional: 실시간 게임
  rpc GameSession(stream GameAction) returns (stream GameState);
  
  // Bidirectional: 협업 편집
  rpc CollaborativeEdit(stream EditOperation) returns (stream DocumentUpdate);
}

message ChatMessage {
  string user_id = 1;
  string room_id = 2;
  string message = 3;
  google.protobuf.Timestamp timestamp = 4;
}

message GameAction {
  string player_id = 1;
  string action_type = 2;  // MOVE, ATTACK, DEFEND
  map<string, string> parameters = 3;
}

message GameState {
  map<string, PlayerState> players = 1;
  string game_status = 2;  // ONGOING, PAUSED, FINISHED
  google.protobuf.Timestamp timestamp = 3;
}

message PlayerState {
  string player_id = 1;
  int32 health = 2;
  int32 score = 3;
  string position = 4;
}

message EditOperation {
  string user_id = 1;
  string document_id = 2;
  string operation_type = 3;  // INSERT, DELETE, FORMAT
  int32 position = 4;
  string content = 5;
}

message DocumentUpdate {
  string document_id = 1;
  string user_id = 2;
  string content = 3;
  repeated string active_users = 4;
  google.protobuf.Timestamp timestamp = 5;
}
```

### Bidirectional Streaming 서버 구현

```go
// server/bidirectional_streaming.go
package main

import (
    "fmt"
    "io"
    "log"
    "sync"
    
    pb "streaming/pb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

// Chat - 양방향 채팅
func (s *StreamingServer) Chat(stream pb.StreamingService_ChatServer) error {
    log.Println("채팅 세션 시작")
    
    // 브로드캐스트를 위한 채널
    messageChan := make(chan *pb.ChatMessage, 100)
    defer close(messageChan)
    
    // 메시지 브로드캐스트 고루틴
    go func() {
        for msg := range messageChan {
            // 에코 메시지 생성
            response := &pb.ChatMessage{
                UserId:    "Server",
                RoomId:    msg.RoomId,
                Message:   fmt.Sprintf("Echo: %s", msg.Message),
                Timestamp: timestamppb.Now(),
            }
            
            if err := stream.Send(response); err != nil {
                log.Printf("메시지 전송 실패: %v", err)
                return
            }
        }
    }()
    
    // 클라이언트 메시지 수신
    for {
        msg, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        log.Printf("채팅 메시지 수신: [%s] %s: %s",
            msg.RoomId, msg.UserId, msg.Message)
        
        // 메시지 브로드캐스트
        select {
        case messageChan <- msg:
        default:
            log.Println("메시지 채널이 가득 참")
        }
    }
}

// GameSession - 실시간 게임 세션
func (s *StreamingServer) GameSession(stream pb.StreamingService_GameSessionServer) error {
    log.Println("게임 세션 시작")
    
    // 게임 상태 관리
    gameState := &GameState{
        players: make(map[string]*pb.PlayerState),
        mu:      sync.RWMutex{},
    }
    
    // 상태 업데이트 브로드캐스트
    updateChan := make(chan bool, 100)
    defer close(updateChan)
    
    go func() {
        for range updateChan {
            gameState.mu.RLock()
            state := &pb.GameState{
                Players:    gameState.players,
                GameStatus: "ONGOING",
                Timestamp:  timestamppb.Now(),
            }
            gameState.mu.RUnlock()
            
            if err := stream.Send(state); err != nil {
                log.Printf("게임 상태 전송 실패: %v", err)
                return
            }
        }
    }()
    
    for {
        action, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        log.Printf("게임 액션: Player=%s, Type=%s",
            action.PlayerId, action.ActionType)
        
        // 게임 로직 처리
        gameState.mu.Lock()
        player, exists := gameState.players[action.PlayerId]
        if !exists {
            player = &pb.PlayerState{
                PlayerId: action.PlayerId,
                Health:   100,
                Score:    0,
                Position: "0,0",
            }
            gameState.players[action.PlayerId] = player
        }
        
        switch action.ActionType {
        case "MOVE":
            if pos, ok := action.Parameters["position"]; ok {
                player.Position = pos
            }
        case "ATTACK":
            player.Score += 10
        case "DEFEND":
            player.Health = min(player.Health+5, 100)
        }
        gameState.mu.Unlock()
        
        // 상태 업데이트 트리거
        select {
        case updateChan <- true:
        default:
        }
    }
}

type GameState struct {
    players map[string]*pb.PlayerState
    mu      sync.RWMutex
}

func min(a, b int32) int32 {
    if a < b {
        return a
    }
    return b
}
```

## 4. 스트리밍 최적화

### 플로우 컨트롤

```go
// server/flow_control.go
package main

import (
    "context"
    "time"
    
    pb "streaming/pb"
)

// 플로우 컨트롤이 적용된 스트리밍
func (s *StreamingServer) ControlledStream(req *pb.StreamRequest, stream pb.StreamingService_ControlledStreamServer) error {
    // 백프레셔 처리
    semaphore := make(chan struct{}, 10) // 최대 10개 동시 처리
    
    for i := 0; i < 100; i++ {
        select {
        case semaphore <- struct{}{}:
            go func(index int) {
                defer func() { <-semaphore }()
                
                // 처리 시뮬레이션
                time.Sleep(100 * time.Millisecond)
                
                data := &pb.StreamData{
                    Id:   index,
                    Data: fmt.Sprintf("Data %d", index),
                }
                
                if err := stream.Send(data); err != nil {
                    log.Printf("전송 실패: %v", err)
                }
            }(i)
            
        case <-stream.Context().Done():
            return stream.Context().Err()
        }
    }
    
    // 모든 고루틴 완료 대기
    for i := 0; i < cap(semaphore); i++ {
        semaphore <- struct{}{}
    }
    
    return nil
}
```

### 에러 처리와 재연결

```go
// client/resilient_streaming.go
package main

import (
    "context"
    "io"
    "time"
    
    pb "streaming/pb"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// 재연결이 가능한 스트리밍 클라이언트
type ResilientStreamClient struct {
    client pb.StreamingServiceClient
    lastID int32
}

func (r *ResilientStreamClient) ConsumeStreamWithRetry(ctx context.Context) {
    retryCount := 0
    maxRetries := 5
    
    for retryCount < maxRetries {
        err := r.consumeStream(ctx)
        
        if err == nil {
            return // 정상 종료
        }
        
        if st, ok := status.FromError(err); ok {
            switch st.Code() {
            case codes.Unavailable, codes.DeadlineExceeded:
                // 재시도 가능한 에러
                retryCount++
                backoff := time.Duration(retryCount) * time.Second
                log.Printf("재연결 시도 %d/%d (대기: %v)", retryCount, maxRetries, backoff)
                time.Sleep(backoff)
                continue
                
            default:
                // 재시도 불가능한 에러
                log.Printf("스트림 에러: %v", err)
                return
            }
        }
    }
    
    log.Printf("최대 재시도 횟수 초과")
}

func (r *ResilientStreamClient) consumeStream(ctx context.Context) error {
    req := &pb.StreamRequest{
        StartFromId: r.lastID, // 마지막 수신 ID부터 재개
    }
    
    stream, err := r.client.GetDataStream(ctx, req)
    if err != nil {
        return err
    }
    
    for {
        data, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        // 마지막 수신 ID 업데이트
        r.lastID = data.Id
        
        log.Printf("데이터 수신: ID=%d, Data=%s", data.Id, data.Data)
    }
}
```

## 5. 성능 최적화 팁

### 버퍼링과 배치 처리

```go
// server/buffered_streaming.go
package main

import (
    "time"
    
    pb "streaming/pb"
)

// 버퍼링된 스트리밍
func (s *StreamingServer) BufferedStream(req *pb.StreamRequest, stream pb.StreamingService_BufferedStreamServer) error {
    buffer := make([]*pb.StreamData, 0, 100)
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    dataChan := make(chan *pb.StreamData, 1000)
    
    // 데이터 생성 고루틴
    go func() {
        for i := 0; i < 1000; i++ {
            dataChan <- &pb.StreamData{
                Id:   int32(i),
                Data: fmt.Sprintf("Data %d", i),
            }
            time.Sleep(10 * time.Millisecond)
        }
        close(dataChan)
    }()
    
    for {
        select {
        case data, ok := <-dataChan:
            if !ok {
                // 남은 버퍼 전송
                if len(buffer) > 0 {
                    for _, item := range buffer {
                        if err := stream.Send(item); err != nil {
                            return err
                        }
                    }
                }
                return nil
            }
            
            buffer = append(buffer, data)
            
            // 버퍼가 가득 차면 전송
            if len(buffer) >= 100 {
                for _, item := range buffer {
                    if err := stream.Send(item); err != nil {
                        return err
                    }
                }
                buffer = buffer[:0]
            }
            
        case <-ticker.C:
            // 주기적으로 버퍼 플러시
            if len(buffer) > 0 {
                for _, item := range buffer {
                    if err := stream.Send(item); err != nil {
                        return err
                    }
                }
                buffer = buffer[:0]
            }
            
        case <-stream.Context().Done():
            return stream.Context().Err()
        }
    }
}
```

## Best Practices

1. **컨텍스트 사용**: 타임아웃과 취소 처리
2. **에러 처리**: 스트림별 적절한 에러 처리
3. **플로우 컨트롤**: 백프레셔 구현
4. **리소스 관리**: 고루틴과 채널 적절히 관리
5. **재연결 로직**: 네트워크 장애 대응
6. **버퍼링**: 효율적인 데이터 전송
7. **모니터링**: 스트림 메트릭 수집

## 다음 단계

스트리밍을 마스터했다면:
1. 인터셉터와 미들웨어
2. 에러 처리 및 모니터링
3. 성능 최적화
4. 프로덕션 배포

## 참고 자료

- [gRPC Streaming Concepts](https://grpc.io/docs/what-is-grpc/core-concepts/#streaming)
- [gRPC Go Streaming](https://grpc.io/docs/languages/go/basics/#streaming-rpcs)
- [HTTP/2 Streams](https://http2.github.io/http2-spec/#StreamsLayer)