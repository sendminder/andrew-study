# Protocol Buffers 완벽 가이드

## Protocol Buffers란?

Protocol Buffers(protobuf)는 Google이 개발한 언어 중립적, 플랫폼 중립적인 구조화된 데이터 직렬화 메커니즘입니다. XML이나 JSON보다 작고, 빠르며, 더 간단합니다.

## 주요 특징

### 장점
- **효율성**: 바이너리 형식으로 크기가 작음 (JSON 대비 3-10배)
- **속도**: 빠른 직렬화/역직렬화 (JSON 대비 20-100배)
- **타입 안정성**: 스키마 기반 강타입
- **버전 호환성**: 스키마 진화 지원
- **다국어 지원**: 여러 언어로 코드 자동 생성

### 단점
- **가독성**: 바이너리 형식으로 사람이 읽기 어려움
- **스키마 필요**: .proto 파일 정의 필수
- **학습 곡선**: 새로운 문법 학습 필요

## Proto3 문법

### 기본 구조
```protobuf
syntax = "proto3";  // 버전 명시 (필수)

package user;       // 패키지 선언
option go_package = "./pb;pb";  // Go 패키지 경로

import "google/protobuf/timestamp.proto";  // 다른 proto 파일 임포트

// 메시지 정의
message User {
  int32 id = 1;
  string name = 2;
  string email = 3;
}
```

## 데이터 타입

### 스칼라 타입

| Proto Type | Go Type | 설명 |
|------------|---------|------|
| double | float64 | 64비트 부동소수점 |
| float | float32 | 32비트 부동소수점 |
| int32 | int32 | 32비트 정수 |
| int64 | int64 | 64비트 정수 |
| uint32 | uint32 | 32비트 양수 |
| uint64 | uint64 | 64비트 양수 |
| sint32 | int32 | 부호있는 32비트 (음수 최적화) |
| sint64 | int64 | 부호있는 64비트 (음수 최적화) |
| fixed32 | uint32 | 고정 32비트 |
| fixed64 | uint64 | 고정 64비트 |
| bool | bool | 불린 |
| string | string | UTF-8 문자열 |
| bytes | []byte | 바이트 배열 |

### 예제: 다양한 타입 사용
```protobuf
message Product {
  int32 id = 1;
  string name = 2;
  double price = 3;
  bool available = 4;
  bytes thumbnail = 5;
  
  // 반복 필드 (배열)
  repeated string tags = 6;
  
  // 맵 타입
  map<string, int32> stock = 7;
}
```

## 메시지 정의

### 기본 메시지
```protobuf
message Person {
  string name = 1;
  int32 age = 2;
  string email = 3;
}
```

### 중첩 메시지
```protobuf
message Company {
  string name = 1;
  
  message Address {
    string street = 1;
    string city = 2;
    string country = 3;
  }
  
  Address headquarters = 2;
  repeated Address branches = 3;
}
```

### 메시지 임포트
```protobuf
// common.proto
message Timestamp {
  int64 seconds = 1;
  int32 nanos = 2;
}

// user.proto
import "common.proto";

message User {
  string name = 1;
  Timestamp created_at = 2;
}
```

## Enum 타입

### 기본 Enum
```protobuf
enum Status {
  UNKNOWN = 0;  // 첫 번째 값은 반드시 0
  ACTIVE = 1;
  INACTIVE = 2;
  DELETED = 3;
}

message User {
  string name = 1;
  Status status = 2;
}
```

### Enum 별칭
```protobuf
enum Priority {
  option allow_alias = true;  // 별칭 허용
  PRIORITY_UNKNOWN = 0;
  PRIORITY_LOW = 1;
  PRIORITY_MEDIUM = 2;
  PRIORITY_HIGH = 3;
  PRIORITY_URGENT = 3;  // HIGH와 같은 값
}
```

## Oneof 필드

여러 필드 중 하나만 설정 가능한 필드 그룹:

```protobuf
message Payment {
  string id = 1;
  
  oneof payment_method {
    CreditCard credit_card = 2;
    BankTransfer bank_transfer = 3;
    PayPal paypal = 4;
  }
  
  message CreditCard {
    string number = 1;
    string cvv = 2;
  }
  
  message BankTransfer {
    string account_number = 1;
    string routing_number = 2;
  }
  
  message PayPal {
    string email = 1;
  }
}
```

## 필드 번호 규칙

### 필드 번호 할당
- 1-15: 1바이트로 인코딩 (자주 사용하는 필드)
- 16-2047: 2바이트로 인코딩
- 19000-19999: 예약된 번호 (사용 금지)

```protobuf
message OptimizedMessage {
  // 자주 사용하는 필드는 1-15 번호 사용
  int32 id = 1;
  string name = 2;
  bool active = 3;
  
  // 덜 중요한 필드는 16 이상
  string description = 16;
  string metadata = 17;
}
```

### 예약 필드
```protobuf
message User {
  reserved 2, 15, 9 to 11;  // 필드 번호 예약
  reserved "foo", "bar";     // 필드 이름 예약
  
  int32 id = 1;
  string name = 3;  // 2는 예약되어 사용 불가
}
```

## 서비스 정의

```protobuf
service UserService {
  // Unary RPC
  rpc GetUser(GetUserRequest) returns (User);
  
  // Server streaming
  rpc ListUsers(ListUsersRequest) returns (stream User);
  
  // Client streaming
  rpc CreateUsers(stream User) returns (CreateUsersResponse);
  
  // Bidirectional streaming
  rpc ChatUsers(stream ChatMessage) returns (stream ChatMessage);
}

message GetUserRequest {
  int32 id = 1;
}

message ListUsersRequest {
  int32 page_size = 1;
  string page_token = 2;
}

message CreateUsersResponse {
  int32 created_count = 1;
}

message ChatMessage {
  int32 user_id = 1;
  string message = 2;
}
```

## Well-Known Types

Google이 제공하는 유용한 타입들:

```protobuf
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/any.proto";

message Event {
  string id = 1;
  
  // Timestamp
  google.protobuf.Timestamp created_at = 2;
  
  // Duration
  google.protobuf.Duration processing_time = 3;
  
  // Wrapper types (nullable)
  google.protobuf.StringValue optional_name = 4;
  google.protobuf.Int32Value optional_count = 5;
  
  // Any type (동적 타입)
  google.protobuf.Any payload = 6;
}

// Empty 사용 예
service HealthService {
  rpc Check(google.protobuf.Empty) returns (google.protobuf.Empty);
}
```

## 고급 기능

### Field Options
```protobuf
import "google/protobuf/descriptor.proto";

extend google.protobuf.FieldOptions {
  string validation = 50001;
}

message User {
  string email = 1 [(validation) = "email"];
  int32 age = 2 [(validation) = "min:0,max:150"];
}
```

### Custom Options
```protobuf
message MyOptions {
  option (my_option) = "custom_value";
  
  string field = 1;
}
```

## Protocol Buffers 컴파일

### 컴파일 명령어
```bash
# Go 코드 생성
protoc --go_out=. --go-grpc_out=. *.proto

# 여러 언어 동시 생성
protoc \
  --go_out=. \
  --java_out=./java \
  --python_out=./python \
  --js_out=./js \
  user.proto
```

### 생성된 Go 코드 사용
```go
package main

import (
    "log"
    pb "myproject/pb"
    "google.golang.org/protobuf/proto"
)

func main() {
    // 메시지 생성
    user := &pb.User{
        Id:    1,
        Name:  "Andrew",
        Email: "andrew@example.com",
    }
    
    // 직렬화
    data, err := proto.Marshal(user)
    if err != nil {
        log.Fatal("마샬링 실패:", err)
    }
    
    // 역직렬화
    newUser := &pb.User{}
    err = proto.Unmarshal(data, newUser)
    if err != nil {
        log.Fatal("언마샬링 실패:", err)
    }
    
    log.Printf("User: %+v", newUser)
}
```

## 스키마 진화 (Schema Evolution)

### 하위 호환성 규칙
1. **필드 추가**: 새 필드는 사용하지 않은 번호 사용
2. **필드 제거**: 필드 삭제 대신 deprecated 또는 reserved 사용
3. **필드 이름 변경**: 번호는 그대로, 이름만 변경 가능
4. **타입 변경**: 호환 가능한 타입끼리만 (int32 ↔ int64)

```protobuf
// v1
message User {
  int32 id = 1;
  string name = 2;
}

// v2 (하위 호환)
message User {
  int32 id = 1;
  string name = 2;
  string email = 3;        // 새 필드 추가 OK
  // string phone = 2;     // 같은 번호 재사용 X
  reserved 4;              // 미래를 위한 예약
  string address = 5;
}
```

## 최적화 팁

### 1. 필드 번호 최적화
```protobuf
message OptimizedUser {
  // 자주 사용: 1-15
  int32 id = 1;
  string username = 2;
  bool active = 3;
  
  // 가끔 사용: 16+
  string bio = 16;
  string website = 17;
}
```

### 2. packed 옵션 (repeated 필드)
```protobuf
message Numbers {
  // packed=true로 효율적 인코딩
  repeated int32 values = 1 [packed=true];
}
```

### 3. 적절한 타입 선택
```protobuf
message Efficient {
  // 양수만: uint32 사용
  uint32 count = 1;
  
  // 음수 가능: sint32 사용 (varint 최적화)
  sint32 temperature = 2;
  
  // 고정 크기: fixed32 사용
  fixed32 ip_address = 3;
}
```

## 디버깅 도구

### protoc 디버깅
```bash
# 텍스트 형식으로 출력
protoc --decode=User user.proto < user.bin

# JSON으로 변환
protoc --decode=User user.proto < user.bin | protoc --encode_json
```

### Go에서 디버깅
```go
import "google.golang.org/protobuf/encoding/protojson"

// Proto를 JSON으로
jsonBytes, _ := protojson.Marshal(user)
fmt.Println(string(jsonBytes))

// JSON을 Proto로
user := &pb.User{}
protojson.Unmarshal(jsonBytes, user)
```

## Best Practices

1. **명확한 네이밍**: 의미 있는 메시지와 필드 이름 사용
2. **버전 관리**: proto 파일도 버전 관리 시스템에 포함
3. **문서화**: 주석으로 각 필드와 메시지 설명
4. **필드 번호 관리**: 스프레드시트로 필드 번호 추적
5. **패키지 구조**: 논리적 패키지 구조 유지

## 다음 단계

Protocol Buffers의 기초를 마스터했다면:
1. gRPC 서버 구현
2. gRPC 클라이언트 구현
3. 스트리밍 구현
4. 성능 최적화

## 참고 자료

- [Protocol Buffers 공식 문서](https://developers.google.com/protocol-buffers)
- [Proto3 Language Guide](https://developers.google.com/protocol-buffers/docs/proto3)
- [Go Generated Code Guide](https://developers.google.com/protocol-buffers/docs/reference/go-generated)