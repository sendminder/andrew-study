# Kafka Advanced: 파티셔닝의 마법 - 어떻게 초당 백만 건을 처리할까?

## 🎬 들어가며: Netflix의 도전

2015년, Netflix 엔지니어팀의 회의실.

**"우리 시청 기록이 초당 100만 건이 넘어요!"**
**"서버를 더 사면 되는 거 아니야?"**
**"아니요, 문제는 하나의 큐에 모든 데이터가 몰린다는 거예요."**

이때 누군가 말했습니다:
**"고속도로가 막히면 어떻게 하죠? 차선을 늘리잖아요!"**

바로 이것이 **Kafka 파티셔닝**의 핵심 아이디어입니다.

## 📚 Chapter 1: 파티션이 없던 시절

### 단일 큐의 한계

상상해보세요. 명절 고속도로 톨게이트:

```
차1 → 차2 → 차3 → 차4 → [톨게이트] → 목적지
```

**문제점:**
- 아무리 빠른 직원이 있어도 한 번에 한 대만 처리
- 차가 많아질수록 대기 시간은 기하급수적 증가
- 직원이 쉬면? 전체 마비!

### 실제 시스템에서는?

```
메시지1 → 메시지2 → 메시지3 → [단일 처리기] → 저장소
```

**초당 1000개 처리가 한계라면?**
- 초당 10,000개가 들어오면? → 9초 지연
- 초당 100,000개가 들어오면? → 99초 지연
- 결과: 시스템 다운! 😱

## 📚 Chapter 2: 파티션의 탄생 - 병렬 처리의 시작

### 고속도로 차선을 늘리듯이

```
이전 (1차선):
차1 → 차2 → 차3 → [톨게이트]

이후 (3차선):
차1 → [톨게이트 1]
차2 → [톨게이트 2]  
차3 → [톨게이트 3]
```

### Kafka의 파티션

```
주문 Topic (파티션 3개):

Partition 0: [주문1, 주문4, 주문7...]
Partition 1: [주문2, 주문5, 주문8...]
Partition 2: [주문3, 주문6, 주문9...]
```

**마법 같은 결과:**
- 처리 속도 3배 향상!
- 한 파티션이 느려도 다른 파티션은 정상 동작
- 수평적 확장 가능 (파티션을 더 추가하면 됨!)

## 📚 Chapter 3: 파티셔닝 전략 - 데이터를 어떻게 나눌까?

### 1. 라운드 로빈 (Round Robin) - 공평하게 나누기

**돌아가면서 하나씩:**

```
메시지 순서: A, B, C, D, E, F

Partition 0: A, D
Partition 1: B, E  
Partition 2: C, F
```

**장점:**
- 완벽한 로드 밸런싱
- 구현이 단순

**단점:**
- 순서 보장 불가능
- 관련 데이터가 흩어짐

**사용 사례:** 로그 수집, 클릭 스트림

### 2. 키 기반 파티셔닝 - 똑똑하게 나누기

**같은 키는 항상 같은 파티션으로:**

```
사용자별 주문 (Key = UserID):

User_A의 모든 주문 → Partition 0
User_B의 모든 주문 → Partition 1
User_C의 모든 주문 → Partition 2
```

**실제 동작 원리:**
```
Partition = Hash(Key) % Partition_Count
```

예시:
- Hash("User_A") = 123456
- 123456 % 3 = 0 → Partition 0

**장점:**
- 같은 사용자의 데이터는 순서 보장
- 관련 데이터가 함께 처리됨

**단점:**
- 핫키 문제 (인기 사용자에게 몰림)

### 3. 커스텀 파티셔닝 - 나만의 규칙

**비즈니스 로직에 따라:**

```java
// VIP 고객은 전용 파티션으로
public int partition(String key, int numPartitions) {
    if (isVIP(key)) {
        return 0; // VIP 전용 파티션
    }
    return hash(key) % (numPartitions - 1) + 1;
}
```

**실제 사례: 지역별 파티셔닝**
```
서울 주문 → Partition 0 (서울 처리 서버)
부산 주문 → Partition 1 (부산 처리 서버)
제주 주문 → Partition 2 (제주 처리 서버)
```

## 📚 Chapter 4: 파티션 개수 결정하기 - 얼마나 많이?

### 마법의 공식은 없지만...

**고려해야 할 요소들:**

1. **목표 처리량 (Throughput)**
   ```
   필요 파티션 수 = 목표 처리량 / 파티션당 처리량
   
   예: 초당 100만 건 목표
       파티션당 초당 10만 건 처리 가능
       필요 파티션 = 10개
   ```

2. **Consumer 수**
   ```
   파티션 수 ≥ Consumer 수
   
   이유: 하나의 파티션은 하나의 Consumer만 읽을 수 있음
   ```

3. **브로커 수**
   ```
   파티션 수 = 브로커 수 × N
   
   균등 분배를 위해 브로커 수의 배수로 설정
   ```

### 실전 예시: 이커머스 주문 시스템

**요구사항:**
- 피크 시간: 초당 50,000 주문
- Consumer: 20대
- 브로커: 5대

**계산:**
```
1. 처리량 기준: 50,000 / 5,000 = 10개
2. Consumer 기준: 20개 (최소)
3. 브로커 기준: 5의 배수 = 20개 또는 25개

결론: 20개 파티션 (모든 조건 만족)
```

## 📚 Chapter 5: 파티션 리밸런싱 - 살아있는 시스템

### 파티션 추가하기

**상황: 트래픽이 2배로 증가!**

```
기존 (3 파티션):
P0: [0, 3, 6, 9...]
P1: [1, 4, 7, 10...]
P2: [2, 5, 8, 11...]

파티션 추가 후 (6 파티션):
P0: [0, 6, 12...]
P1: [1, 7, 13...]
P2: [2, 8, 14...]
P3: [3, 9, 15...]  ← 새 파티션
P4: [4, 10, 16...] ← 새 파티션
P5: [5, 11, 17...] ← 새 파티션
```

**주의사항:**
- 키 기반 파티셔닝의 경우 데이터 재분배 발생
- 순서 보장이 일시적으로 깨질 수 있음
- 점진적 마이그레이션 전략 필요

### Consumer 리밸런싱

```
상황: Consumer 3대 → 6대로 증가

이전:
Consumer1: P0, P1
Consumer2: P2, P3
Consumer3: P4, P5

이후:
Consumer1: P0
Consumer2: P1
Consumer3: P2
Consumer4: P3 ← 새 Consumer
Consumer5: P4 ← 새 Consumer
Consumer6: P5 ← 새 Consumer
```

## 📚 Chapter 6: 파티셔닝 함정과 해결책

### 1. 핫 파티션 (Hot Partition)

**문제 상황:**
```
유명 셀럽의 게시글:
셀럽A의 활동 → Partition 0 (과부하!)
일반 사용자들 → Partition 1,2,3 (한산함)
```

**해결책:**
```java
// 핫키 감지 및 분산
if (isHotKey(key)) {
    // 랜덤 서브키 추가
    String subKey = key + "_" + random.nextInt(10);
    return hash(subKey) % numPartitions;
}
```

### 2. 순서 보장 문제

**문제:**
```
주문 → 결제 → 배송 (순서 중요!)

다른 파티션으로 가면 순서가 뒤바뀔 수 있음
```

**해결책:**
```
OrderID를 키로 사용:
Order_123 → 항상 같은 파티션
Payment_123 → 같은 파티션
Shipping_123 → 같은 파티션
```

### 3. 파티션 수 변경의 어려움

**문제:** 한 번 만든 파티션 수는 줄이기 어려움

**해결책:**
- 처음부터 넉넉하게 설정 (하지만 과하지 않게)
- 성장 예측을 고려한 설계
- 테스트 환경에서 충분히 검증

## 🎯 실전 팁: 파티셔닝 베스트 프랙티스

### 1. 시작은 작게
```
개발: 1개 파티션
테스트: 3개 파티션
프로덕션: 실제 부하에 맞춰 증가
```

### 2. 모니터링 지표
```
반드시 확인해야 할 것들:
- 파티션별 메시지 수
- 파티션별 지연 시간
- Consumer Lag
- 파티션 불균형 비율
```

### 3. 파티션 키 선택 가이드
```
Good Keys:
✅ UserID (사용자별 처리)
✅ OrderID (주문별 처리)
✅ SessionID (세션별 처리)

Bad Keys:
❌ Timestamp (모든 데이터가 한 파티션으로)
❌ Country (불균형 심함)
❌ Status (적은 종류의 값)
```

## 💭 생각해볼 문제들

1. **파티션을 무한정 늘리면 어떻게 될까요?**
   - 힌트: 메타데이터 관리, 리밸런싱 비용

2. **파티션 0번이 고장나면 어떻게 될까요?**
   - 힌트: Replication과 연계해서 생각

3. **실시간 순위 시스템에서 파티셔닝을 어떻게 할까요?**
   - 힌트: 전체 데이터를 봐야 하는 경우

## 🚀 핵심 정리

### 파티셔닝을 한 문장으로?
> **"하나의 큰 일을 여러 개의 작은 일로 나누어 동시에 처리하는 기술"**

### 기억해야 할 세 가지
1. **파티션 = 병렬 처리의 단위**
2. **파티션 키 = 데이터가 갈 곳을 결정**
3. **더 많은 파티션 ≠ 항상 좋음**

### 언제 파티션을 늘려야 할까?
- Consumer가 따라잡지 못할 때
- 처리 지연이 증가할 때
- 스케일 아웃이 필요할 때

## 🎬 다음 시간 예고

**"파티션이 여러 개인데, 하나가 죽으면 어떡하죠?"**

다음 시간에는 **복제(Replication)**에 대해 알아보겠습니다:
- Leader와 Follower의 역할
- 데이터를 절대 잃지 않는 방법
- CAP 이론과 Kafka의 선택

파티셔닝은 Kafka의 **성능**을 책임진다면,
복제는 Kafka의 **신뢰성**을 책임집니다!

---

*"분산 시스템의 첫 번째 규칙: 모든 것을 나누되, 중요한 것은 여러 개 만들어라."*