# TCP 완벽 이해: 신뢰성 있는 통신의 비밀

안녕하세요! 오늘은 TCP의 내부 동작을 깊이 파헤쳐보겠습니다. TCP가 어떻게 신뢰성을 보장하는지, 성능을 최적화하는지 함께 알아볼까요?

## TCP는 어떻게 연결을 맺을까? - 3-Way Handshake

TCP 연결의 시작은 악수입니다. 정확히는 3번의 악수죠.

### 3-Way Handshake 과정

```
Client                          Server
  |                                |
  |  ---- SYN (seq=x) ------>      |  1. 연결 요청
  |                                |
  |  <--- SYN-ACK (seq=y, ack=x+1) |  2. 연결 수락
  |                                |
  |  ---- ACK (ack=y+1) ----->     |  3. 연결 확립
  |                                |
  [연결 수립 완료]
```

이 과정이 왜 필요할까요? 

**첫 번째 이유: 양방향 통신 확인**
- 클라이언트 → 서버 통신 가능 확인
- 서버 → 클라이언트 통신 가능 확인

**두 번째 이유: 시퀀스 번호 동기화**
- 각자의 초기 시퀀스 번호(ISN) 교환
- 데이터 순서 보장의 기준점 설정

**세 번째 이유: 오래된 연결 방지**
- 이전 연결의 패킷이 새 연결에 영향 주는 것 방지

### 실무 팁: SYN Flooding 공격

제가 운영하던 서비스가 SYN Flooding 공격을 받은 적이 있습니다. 공격자가 대량의 SYN 패킷을 보내고 ACK를 보내지 않아 서버의 연결 대기 큐가 가득 차버렸죠.

**대응 방법:**
- SYN Cookies 활성화
- SYN Backlog 크기 조정
- Rate Limiting 적용
- DDoS 방어 서비스 활용

## 연결을 종료하는 4-Way Handshake

연결을 끊을 때는 4번의 과정이 필요합니다.

```
Client                          Server
  |                                |
  |  ---- FIN (seq=x) ------>      |  1. 종료 요청
  |                                |
  |  <--- ACK (ack=x+1) ----       |  2. 종료 요청 확인
  |                                |
  |  <--- FIN (seq=y) ------       |  3. 서버도 종료 준비 완료
  |                                |
  |  ---- ACK (ack=y+1) ----->     |  4. 최종 확인
  |                                |
  [TIME_WAIT 상태]                 [연결 종료]
```

### TIME_WAIT의 미스터리

연결을 종료한 후에도 소켓은 TIME_WAIT 상태로 일정 시간(보통 2MSL, 약 1-4분) 남아있습니다. 왜일까요?

1. **지연된 패킷 처리**: 네트워크에 남아있을 수 있는 패킷 처리
2. **연결 재사용 방지**: 같은 포트로 즉시 새 연결 방지

실무에서 TIME_WAIT가 많이 쌓이면 포트 고갈 문제가 발생할 수 있습니다. 특히 마이크로서비스 환경에서 자주 겪는 문제죠.

## 슬라이딩 윈도우: TCP의 효율성 비밀

TCP는 어떻게 효율적으로 데이터를 전송할까요? 답은 슬라이딩 윈도우입니다.

### 윈도우의 개념

```
송신 윈도우:
[전송 완료] [전송 중] [전송 가능] [대기 중]
    ↑          ↑         ↑           ↑
   ACK 수신   미확인    윈도우 내   윈도우 밖

수신 윈도우:
[수신 완료] [수신 가능] [버퍼 초과]
    ↑          ↑           ↑
  처리 완료   버퍼 여유   버퍼 부족
```

### 윈도우 크기 조절

윈도우 크기는 동적으로 조절됩니다:

1. **수신 윈도우**: 수신 버퍼의 여유 공간
2. **혼잡 윈도우**: 네트워크 상황에 따른 제한
3. **실제 윈도우**: min(수신 윈도우, 혼잡 윈도우)

제가 대용량 파일 전송 시스템을 개발할 때, 윈도우 크기 튜닝만으로 전송 속도를 3배 향상시킨 경험이 있습니다.

## 혼잡 제어: 네트워크 트래픽 경찰

TCP는 네트워크 혼잡을 어떻게 감지하고 대응할까요?

### Slow Start (느린 시작)

연결 초기에는 조심스럽게 시작합니다:

```
혼잡 윈도우 크기:
1 MSS → 2 MSS → 4 MSS → 8 MSS → 16 MSS...
(지수적 증가)
```

### Congestion Avoidance (혼잡 회피)

임계값(ssthresh)에 도달하면 선형적으로 증가:

```
16 MSS → 17 MSS → 18 MSS → 19 MSS...
(선형 증가)
```

### Fast Retransmit & Fast Recovery

패킷 손실 감지 시 빠른 대응:

1. **3개의 중복 ACK** 수신 → 패킷 손실 추정
2. **즉시 재전송** (타임아웃 기다리지 않음)
3. **혼잡 윈도우 절반으로 감소**

### 혼잡 제어 알고리즘의 진화

```
전통적 알고리즘:
- Tahoe (1988): 기본 혼잡 제어
- Reno (1990): Fast Recovery 추가
- NewReno (1999): 다중 패킷 손실 처리 개선

현대적 알고리즘:
- CUBIC (Linux 기본): 3차 함수 기반
- BBR (Google): 대역폭과 RTT 기반
- Vegas: 지연 시간 기반
```

## TCP 성능 최적화 기법

### 1. Nagle 알고리즘

작은 패킷들을 모아서 전송:

**장점:**
- 네트워크 효율성 증가
- 오버헤드 감소

**단점:**
- 지연 시간 증가
- 실시간 애플리케이션에 부적합

**실무 팁:** 
채팅 서버나 게임 서버에서는 TCP_NODELAY 옵션으로 비활성화하세요.

### 2. Delayed ACK

ACK를 즉시 보내지 않고 잠시 대기:

- 일반적으로 200ms 대기
- 데이터와 함께 ACK 전송 (Piggybacking)
- 네트워크 트래픽 감소

### 3. TCP Fast Open (TFO)

3-way handshake 중에 데이터 전송:

```
기존 방식: SYN → SYN-ACK → ACK → Data
TFO 방식: SYN + Data → SYN-ACK + Data → ACK
```

1 RTT 단축 효과!

## TCP 튜닝 파라미터

### 리눅스 커널 파라미터

```bash
# 수신 버퍼 크기
net.core.rmem_default
net.core.rmem_max
net.ipv4.tcp_rmem

# 송신 버퍼 크기
net.core.wmem_default
net.core.wmem_max
net.ipv4.tcp_wmem

# 연결 대기 큐
net.core.somaxconn
net.ipv4.tcp_max_syn_backlog

# TIME_WAIT 관련
net.ipv4.tcp_tw_reuse
net.ipv4.tcp_tw_recycle

# Keep-Alive
net.ipv4.tcp_keepalive_time
net.ipv4.tcp_keepalive_intvl
net.ipv4.tcp_keepalive_probes
```

## 실무 사례: TCP 최적화 경험

### 사례 1: 글로벌 서비스의 지연 시간 개선

문제: 해외 사용자의 응답 시간이 너무 느림

해결:
1. TCP Fast Open 활성화 → 초기 연결 시간 30% 단축
2. BBR 혼잡 제어 알고리즘 적용 → 처리량 25% 향상
3. 초기 혼잡 윈도우 크기 증가 (initcwnd) → 첫 응답 속도 개선

### 사례 2: 대용량 파일 전송 최적화

문제: 100GB 이상 파일 전송 시 속도 저하

해결:
1. 수신/송신 버퍼 크기 증가 (128MB)
2. Window Scaling 활성화
3. SACK (Selective ACK) 활성화
4. 결과: 전송 속도 5배 향상

### 사례 3: 마이크로서비스 간 통신 최적화

문제: 서비스 간 호출이 많아 TIME_WAIT 소켓 누적

해결:
1. HTTP Keep-Alive 활성화
2. Connection Pooling 구현
3. tcp_tw_reuse 활성화
4. 결과: 포트 고갈 문제 해결, 응답 시간 40% 개선

## TCP의 한계와 대안

### TCP의 근본적 한계

1. **Head-of-Line Blocking**: 하나의 패킷 손실이 전체 스트림 차단
2. **연결 수립 오버헤드**: 3-way handshake 필수
3. **모바일 환경 부적합**: IP 변경 시 연결 재수립 필요

### QUIC: TCP의 진화

구글이 개발한 QUIC은 UDP 기반으로 TCP의 한계를 극복:

- 0-RTT 연결 수립
- 멀티플렉싱 지원
- 연결 마이그레이션
- 향상된 혼잡 제어

### MPTCP: 다중 경로 TCP

여러 네트워크 경로를 동시에 사용:

- Wi-Fi와 LTE 동시 사용
- 경로 장애 시 자동 전환
- 대역폭 집약

## 마무리: TCP 마스터가 되는 길

TCP를 깊이 이해하면 네트워크 문제를 해결하는 능력이 크게 향상됩니다. 

제가 추천하는 학습 방법:
1. **Wireshark로 패킷 분석**: 실제 TCP 동작 관찰
2. **커널 파라미터 실험**: 다양한 설정값 테스트
3. **부하 테스트**: 극한 상황에서의 TCP 동작 확인
4. **최신 연구 follow-up**: BBR, QUIC 등 새로운 기술

TCP는 40년이 넘은 프로토콜이지만 여전히 진화하고 있습니다. 기본을 탄탄히 다지고 최신 기술을 따라가다 보면, 어느새 네트워크 전문가가 되어 있을 거예요!

다음 시간에는 HTTP의 진화와 최적화에 대해 알아보겠습니다. HTTP/3까지의 여정, 기대되지 않나요? 🚀