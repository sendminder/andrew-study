# 4강: React Hooks 완전 마스터

## 🎯 학습 목표
- React Hooks가 왜 혁신적인지 이해하고 Class Component와 비교할 수 있다
- useState, useEffect를 완벽하게 활용할 수 있다
- useContext로 prop drilling 문제를 해결할 수 있다
- useMemo, useCallback으로 성능 최적화를 할 수 있다
- Custom Hooks를 만들어서 로직을 재사용할 수 있다

---

## 🤔 Class Component의 한계와 Hooks의 혁신

### Class Component의 문제점

```jsx
// 😢 Class Component - 복잡하고 이해하기 어려운 생명주기
class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      posts: [],
      loading: true,
      error: null
    };
  }

  async componentDidMount() {
    try {
      // 사용자 정보 가져오기
      const userResponse = await fetch(`/api/users/${this.props.userId}`);
      const user = await userResponse.json();
      
      // 사용자 포스트 가져오기
      const postsResponse = await fetch(`/api/users/${user.id}/posts`);
      const posts = await postsResponse.json();
      
      this.setState({ user, posts, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  }

  async componentDidUpdate(prevProps) {
    // props가 변경되면 다시 데이터 가져오기
    if (prevProps.userId !== this.props.userId) {
      this.setState({ loading: true });
      // 위의 로직을 또 써야 함... DRY 위반!
    }
  }

  componentWillUnmount() {
    // cleanup 로직
  }

  render() {
    const { user, posts, loading, error } = this.state;
    
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error}</div>;
    
    return (
      <div>
        <h1>{user.name}</h1>
        <div>Posts: {posts.length}</div>
      </div>
    );
  }
}
```

**Class Component의 문제:**
- 😵 **복잡한 생명주기**: componentDidMount, componentDidUpdate 등등
- 🔄 **로직 중복**: 같은 로직을 여러 곳에 써야 함
- 🧩 **로직 재사용 어려움**: HOC, Render Props 등 복잡한 패턴 필요
- 📝 **더 많은 코드**: 보일러플레이트 코드가 많음
- 🤯 **this 바인딩 이슈**: 이벤트 핸들러마다 bind 또는 화살표 함수 필요

### Hooks의 혁신

```tsx
// 😍 Hooks - 간단하고 직관적
import { useState, useEffect } from 'react';

interface User {
  id: number;
  name: string;
}

interface Post {
  id: number;
  title: string;
  userId: number;
}

const UserProfile: React.FC<{ userId: number }> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null);
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUserData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        // 사용자 정보와 포스트를 동시에 가져오기
        const [userResponse, postsResponse] = await Promise.all([
          fetch(`/api/users/${userId}`),
          fetch(`/api/users/${userId}/posts`)
        ]);
        
        const userData = await userResponse.json();
        const postsData = await postsResponse.json();
        
        setUser(userData);
        setPosts(postsData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchUserData();
  }, [userId]); // userId가 변경될 때만 실행

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h1>{user?.name}</h1>
      <div>Posts: {posts.length}</div>
    </div>
  );
};
```

**Hooks의 장점:**
- ✅ **간단한 API**: useState, useEffect 만으로 모든 상태와 생명주기 관리
- 🔄 **로직 재사용 쉬움**: Custom Hooks로 로직 추출
- 📝 **적은 코드**: 보일러플레이트 대폭 감소
- 🎯 **관심사 분리**: 관련 로직을 한 곳에 모을 수 있음
- 💪 **더 강력**: 함수형 프로그래밍 패러다임

---

## 📊 useState: 상태 관리의 기본

### 기본 사용법

```tsx
import { useState } from 'react';

const Counter: React.FC = () => {
  // 😍 간단한 상태 선언
  const [count, setCount] = useState<number>(0);
  
  // 여러 상태를 각각 관리
  const [name, setName] = useState<string>('');
  const [isVisible, setIsVisible] = useState<boolean>(true);

  return (
    <div>
      <h2>카운터: {count}</h2>
      <button onClick={() => setCount(count + 1)}>
        증가 (+1)
      </button>
      <button onClick={() => setCount(prev => prev - 1)}>
        감소 (-1) {/* 함수형 업데이트 */}
      </button>
      
      <div>
        <input 
          value={name} 
          onChange={(e) => setName(e.target.value)}
          placeholder="이름을 입력하세요"
        />
        <p>안녕하세요, {name || '익명'}님!</p>
      </div>
      
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? '숨기기' : '보이기'}
      </button>
      {isVisible && <div>토글되는 내용입니다!</div>}
    </div>
  );
};
```

### 객체와 배열 상태 관리

```tsx
interface TodoItem {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  const [todos, setTodos] = useState<TodoItem[]>([]);
  const [inputText, setInputText] = useState('');

  const addTodo = () => {
    if (inputText.trim()) {
      const newTodo: TodoItem = {
        id: Date.now(),
        text: inputText.trim(),
        completed: false
      };
      
      // 😍 배열 상태 업데이트 - spread operator 사용
      setTodos(prevTodos => [...prevTodos, newTodo]);
      setInputText('');
    }
  };

  const toggleTodo = (id: number) => {
    // 😍 불변성을 지키면서 업데이트
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };

  const deleteTodo = (id: number) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };

  const completedCount = todos.filter(todo => todo.completed).length;
  const totalCount = todos.length;

  return (
    <div className="todo-app">
      <h1>할 일 관리</h1>
      
      <div className="input-section">
        <input
          type="text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="새 할 일을 입력하세요..."
        />
        <button onClick={addTodo}>추가</button>
      </div>

      <div className="stats">
        진행률: {totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0}%
        ({completedCount} / {totalCount})
      </div>

      <ul className="todo-list">
        {todos.map(todo => (
          <li key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span className="todo-text">{todo.text}</span>
            <button onClick={() => deleteTodo(todo.id)}>삭제</button>
          </li>
        ))}
      </ul>

      {todos.length === 0 && (
        <p className="empty-message">아직 할 일이 없습니다. 새로운 할 일을 추가해보세요!</p>
      )}
    </div>
  );
};
```

**useState 핵심 포인트:**
- ✅ **함수형 업데이트**: `setState(prev => prev + 1)` 권장
- ✅ **불변성 유지**: 객체/배열을 직접 수정하지 말고 새로 만들기
- ✅ **적절한 초기값**: 타입에 맞는 초기값 설정
- ⚠️ **상태 분리**: 관련 없는 상태는 따로 관리

---

## ⚡ useEffect: 사이드 이펙트의 마법사

### 기본 개념과 생명주기 매핑

```tsx
import { useState, useEffect } from 'react';

const LifecycleExample: React.FC = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // 1️⃣ componentDidMount와 같음 (의존성 배열이 빈 배열)
  useEffect(() => {
    console.log('컴포넌트가 마운트되었습니다!');
    
    // API 호출, 구독 설정 등 초기화 작업
    document.title = 'React Hooks 강의';
    
    // 2️⃣ componentWillUnmount와 같음 (cleanup function)
    return () => {
      console.log('컴포넌트가 언마운트됩니다!');
      document.title = 'React App'; // 원래대로 복구
    };
  }, []); // 빈 배열 = 한 번만 실행

  // 3️⃣ componentDidUpdate와 같음 (특정 값이 변경될 때)
  useEffect(() => {
    console.log(`count가 ${count}로 변경되었습니다!`);
    
    if (count > 10) {
      alert('카운트가 10을 초과했습니다!');
    }
  }, [count]); // count가 변경될 때만 실행

  // 4️⃣ 모든 렌더링 후에 실행 (의존성 배열 없음)
  useEffect(() => {
    console.log('매 렌더링마다 실행됩니다');
    // 성능상 좋지 않으므로 특별한 경우가 아니면 사용하지 않음
  });

  return (
    <div>
      <h2>카운트: {count}</h2>
      <button onClick={() => setCount(count + 1)}>증가</button>
      
      <div>
        <input 
          value={name} 
          onChange={(e) => setName(e.target.value)}
          placeholder="이름 입력"
        />
        <p>이름: {name}</p>
      </div>
    </div>
  );
};
```

### 실전 데이터 페칭

```tsx
interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

interface ApiError {
  message: string;
  status: number;
}

const UserProfile: React.FC<{ userId: number }> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<ApiError | null>(null);

  useEffect(() => {
    // 😍 async/await를 useEffect 안에서 사용하는 패턴
    const fetchUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        // 실제 API 호출
        const response = await fetch(`/api/users/${userId}`);
        
        if (!response.ok) {
          throw {
            message: `사용자를 찾을 수 없습니다 (${response.status})`,
            status: response.status
          };
        }
        
        const userData = await response.json();
        setUser(userData);
        
      } catch (err) {
        console.error('사용자 데이터 로딩 실패:', err);
        setError(err as ApiError);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]); // userId가 변경되면 다시 실행

  // 로딩 상태
  if (loading) {
    return (
      <div className="loading-container">
        <div className="spinner"></div>
        <p>사용자 정보를 불러오는 중...</p>
      </div>
    );
  }

  // 에러 상태
  if (error) {
    return (
      <div className="error-container">
        <h3>⚠️ 오류가 발생했습니다</h3>
        <p>{error.message}</p>
        <button onClick={() => window.location.reload()}>
          다시 시도하기
        </button>
      </div>
    );
  }

  // 정상 상태
  return (
    <div className="user-profile">
      <div className="user-avatar">
        <img 
          src={user?.avatar || '/default-avatar.png'} 
          alt={`${user?.name} 아바타`}
          onError={(e) => {
            // 이미지 로딩 실패시 기본 이미지로 교체
            e.currentTarget.src = '/default-avatar.png';
          }}
        />
      </div>
      
      <div className="user-info">
        <h2>{user?.name}</h2>
        <p>{user?.email}</p>
      </div>
    </div>
  );
};
```

### 타이머와 구독 관리

```tsx
const TimerApp: React.FC = () => {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    let intervalId: NodeJS.Timeout;

    if (isRunning) {
      // 타이머 시작
      intervalId = setInterval(() => {
        setSeconds(prevSeconds => prevSeconds + 1);
      }, 1000);
    }

    // 😍 cleanup 함수로 타이머 정리
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isRunning]); // isRunning이 변경될 때마다 실행

  // 키보드 이벤트 리스너 등록
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.code === 'Space') {
        event.preventDefault();
        setIsRunning(prev => !prev);
      } else if (event.code === 'KeyR') {
        setSeconds(0);
        setIsRunning(false);
      }
    };

    // 이벤트 리스너 등록
    document.addEventListener('keydown', handleKeyPress);

    // 😍 cleanup 함수로 이벤트 리스너 제거
    return () => {
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, []); // 한 번만 등록

  const formatTime = (totalSeconds: number) => {
    const minutes = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="timer-app">
      <h1>스톱워치</h1>
      
      <div className="timer-display">
        {formatTime(seconds)}
      </div>
      
      <div className="timer-controls">
        <button onClick={() => setIsRunning(!isRunning)}>
          {isRunning ? '일시정지' : '시작'}
        </button>
        <button onClick={() => { setSeconds(0); setIsRunning(false); }}>
          리셋
        </button>
      </div>
      
      <div className="timer-instructions">
        <p>💡 단축키: 스페이스바(시작/정지), R(리셋)</p>
      </div>
    </div>
  );
};
```

**useEffect 핵심 포인트:**
- ✅ **의존성 배열 정확히**: 사용하는 모든 값을 의존성에 포함
- ✅ **cleanup 함수**: 메모리 누수 방지를 위해 정리 작업 필수
- ✅ **async 함수**: useEffect 내부에서 별도 함수로 정의
- ⚠️ **무한 루프 주의**: 의존성 배열을 올바르게 설정

---

## 🌐 useContext: Prop Drilling 해결사

### Prop Drilling 문제

```tsx
// 😢 Props를 여러 단계로 전달하는 비효율적인 방식
const App = () => {
  const [user, setUser] = useState({ name: 'Andrew', theme: 'dark' });
  
  return (
    <div>
      <Header user={user} />
      <Main user={user} />
      <Footer user={user} />
    </div>
  );
};

const Header = ({ user }) => {
  return (
    <header>
      <Navigation user={user} />
    </header>
  );
};

const Navigation = ({ user }) => {
  return (
    <nav>
      <UserMenu user={user} />
    </nav>
  );
};

// 결국 여기서만 user를 사용하는데 여러 컴포넌트를 거쳐서 전달됨
const UserMenu = ({ user }) => {
  return <div>안녕하세요, {user.name}님!</div>;
};
```

### Context API로 해결

```tsx
import { createContext, useContext, useState, ReactNode } from 'react';

// 1️⃣ Context 타입 정의
interface User {
  id: number;
  name: string;
  email: string;
  theme: 'light' | 'dark';
}

interface UserContextType {
  user: User | null;
  updateUser: (user: User) => void;
  toggleTheme: () => void;
  logout: () => void;
}

// 2️⃣ Context 생성
const UserContext = createContext<UserContextType | undefined>(undefined);

// 3️⃣ Context Provider 컴포넌트
interface UserProviderProps {
  children: ReactNode;
}

export const UserProvider: React.FC<UserProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>({
    id: 1,
    name: 'Andrew',
    email: 'andrew@example.com',
    theme: 'light'
  });

  const updateUser = (newUser: User) => {
    setUser(newUser);
    // 로컬 스토리지에 저장
    localStorage.setItem('user', JSON.stringify(newUser));
  };

  const toggleTheme = () => {
    if (user) {
      const newTheme = user.theme === 'light' ? 'dark' : 'light';
      updateUser({ ...user, theme: newTheme });
    }
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
  };

  const value = {
    user,
    updateUser,
    toggleTheme,
    logout
  };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
};

// 4️⃣ Context를 사용하는 커스텀 훅
export const useUser = (): UserContextType => {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    throw new Error('useUser는 UserProvider 내부에서 사용해야 합니다');
  }
  
  return context;
};

// 5️⃣ App 컴포넌트에서 Provider 설정
const App = () => {
  return (
    <UserProvider>
      <div className="app">
        <Header />
        <Main />
        <Footer />
      </div>
    </UserProvider>
  );
};

// 6️⃣ 어디서든 Context 사용 가능
const Header = () => {
  const { user, toggleTheme } = useUser();
  
  return (
    <header className={`header ${user?.theme}`}>
      <h1>내 앱</h1>
      <Navigation />
    </header>
  );
};

const Navigation = () => {
  return (
    <nav>
      <UserMenu />
    </nav>
  );
};

// 😍 Props 전달 없이 바로 Context 사용!
const UserMenu = () => {
  const { user, toggleTheme, logout } = useUser();
  
  if (!user) {
    return <button>로그인</button>;
  }
  
  return (
    <div className="user-menu">
      <span>안녕하세요, {user.name}님!</span>
      <button onClick={toggleTheme}>
        {user.theme === 'light' ? '🌙' : '☀️'} 테마 변경
      </button>
      <button onClick={logout}>로그아웃</button>
    </div>
  );
};

const Main = () => {
  const { user } = useUser();
  
  return (
    <main className={`main ${user?.theme}`}>
      <h2>메인 콘텐츠</h2>
      {user ? (
        <div>
          <p>{user.name}님의 대시보드입니다.</p>
          <UserSettings />
        </div>
      ) : (
        <p>로그인이 필요합니다.</p>
      )}
    </main>
  );
};

const UserSettings = () => {
  const { user, updateUser } = useUser();
  const [name, setName] = useState(user?.name || '');
  
  const handleSave = () => {
    if (user && name.trim()) {
      updateUser({ ...user, name: name.trim() });
      alert('설정이 저장되었습니다!');
    }
  };
  
  return (
    <div className="user-settings">
      <h3>사용자 설정</h3>
      <div>
        <label>이름:</label>
        <input 
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
        <button onClick={handleSave}>저장</button>
      </div>
    </div>
  );
};
```

**useContext 장점:**
- ✅ **Prop Drilling 해결**: 중간 컴포넌트들이 불필요한 props를 받지 않음
- ✅ **전역 상태**: 앱 어디서든 접근 가능한 상태
- ✅ **타입 안전성**: TypeScript와 완벽 호환
- ✅ **성능**: 필요한 컴포넌트만 리렌더링

---

## 🚀 성능 최적화: useMemo와 useCallback

### useMemo: 비싼 계산 결과 캐싱

```tsx
import { useState, useMemo, useCallback } from 'react';

interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
  rating: number;
}

const ProductList: React.FC = () => {
  const [products] = useState<Product[]>([
    { id: 1, name: '노트북', price: 1500000, category: '전자기기', rating: 4.5 },
    { id: 2, name: '마우스', price: 50000, category: '전자기기', rating: 4.2 },
    { id: 3, name: '키보드', price: 120000, category: '전자기기', rating: 4.7 },
    // ... 수백 개의 제품
  ]);
  
  const [filterCategory, setFilterCategory] = useState('');
  const [sortBy, setSortBy] = useState<'price' | 'rating'>('price');
  const [searchTerm, setSearchTerm] = useState('');

  // 😍 useMemo로 비싼 계산 결과 캐싱
  const filteredAndSortedProducts = useMemo(() => {
    console.log('필터링과 정렬 계산 중...'); // 언제 계산되는지 확인
    
    let filtered = products;
    
    // 카테고리 필터링
    if (filterCategory) {
      filtered = filtered.filter(product => product.category === filterCategory);
    }
    
    // 검색어 필터링
    if (searchTerm) {
      filtered = filtered.filter(product => 
        product.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // 정렬
    filtered.sort((a, b) => {
      if (sortBy === 'price') {
        return a.price - b.price;
      } else {
        return b.rating - a.rating;
      }
    });
    
    return filtered;
  }, [products, filterCategory, searchTerm, sortBy]); // 의존성 배열

  // 😍 통계 계산도 useMemo로 최적화
  const statistics = useMemo(() => {
    const totalProducts = filteredAndSortedProducts.length;
    const averagePrice = totalProducts > 0 
      ? filteredAndSortedProducts.reduce((sum, p) => sum + p.price, 0) / totalProducts 
      : 0;
    const averageRating = totalProducts > 0
      ? filteredAndSortedProducts.reduce((sum, p) => sum + p.rating, 0) / totalProducts
      : 0;
    
    return {
      totalProducts,
      averagePrice: Math.round(averagePrice),
      averageRating: Math.round(averageRating * 10) / 10
    };
  }, [filteredAndSortedProducts]);

  return (
    <div className="product-list">
      <h1>상품 목록</h1>
      
      {/* 필터 및 검색 UI */}
      <div className="controls">
        <input
          type="text"
          placeholder="상품명 검색..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
        
        <select
          value={filterCategory}
          onChange={(e) => setFilterCategory(e.target.value)}
        >
          <option value="">모든 카테고리</option>
          <option value="전자기기">전자기기</option>
        </select>
        
        <select
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value as 'price' | 'rating')}
        >
          <option value="price">가격순</option>
          <option value="rating">평점순</option>
        </select>
      </div>
      
      {/* 통계 정보 */}
      <div className="statistics">
        <p>총 {statistics.totalProducts}개 상품</p>
        <p>평균 가격: {statistics.averagePrice.toLocaleString()}원</p>
        <p>평균 평점: {statistics.averageRating}점</p>
      </div>
      
      {/* 상품 목록 */}
      <div className="products">
        {filteredAndSortedProducts.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
};
```

### useCallback: 함수 재생성 방지

```tsx
import React, { useState, useCallback, memo } from 'react';

// 😍 React.memo로 래핑된 자식 컴포넌트 (props가 변경되지 않으면 리렌더링 안됨)
const ProductCard = memo<{ 
  product: Product;
  onAddToCart: (productId: number) => void;
  onToggleFavorite: (productId: number) => void;
}>(({ product, onAddToCart, onToggleFavorite }) => {
  console.log(`ProductCard ${product.name} 렌더링됨`); // 렌더링 횟수 확인
  
  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <p>가격: {product.price.toLocaleString()}원</p>
      <p>평점: ⭐ {product.rating}</p>
      
      <div className="buttons">
        <button onClick={() => onAddToCart(product.id)}>
          장바구니 추가
        </button>
        <button onClick={() => onToggleFavorite(product.id)}>
          ❤️ 찜하기
        </button>
      </div>
    </div>
  );
});

const ShoppingApp: React.FC = () => {
  const [products] = useState<Product[]>([
    // ... 상품 데이터
  ]);
  const [cart, setCart] = useState<number[]>([]);
  const [favorites, setFavorites] = useState<number[]>([]);
  const [searchTerm, setSearchTerm] = useState('');

  // 😢 매번 새로운 함수가 생성되어 ProductCard가 불필요하게 리렌더링됨
  // const addToCart = (productId: number) => {
  //   setCart(prev => [...prev, productId]);
  // };

  // 😍 useCallback으로 함수 메모이제이션
  const addToCart = useCallback((productId: number) => {
    setCart(prev => {
      if (!prev.includes(productId)) {
        return [...prev, productId];
      }
      return prev;
    });
    
    // 사용자 피드백
    alert('장바구니에 추가되었습니다!');
  }, []); // 의존성이 없으므로 함수는 한 번만 생성됨

  const toggleFavorite = useCallback((productId: number) => {
    setFavorites(prev => {
      if (prev.includes(productId)) {
        return prev.filter(id => id !== productId);
      } else {
        return [...prev, productId];
      }
    });
  }, []);

  // 검색 결과도 useMemo로 최적화
  const filteredProducts = useMemo(() => {
    return products.filter(product => 
      product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [products, searchTerm]);

  return (
    <div className="shopping-app">
      <header>
        <h1>온라인 쇼핑몰</h1>
        <div className="header-info">
          <span>장바구니: {cart.length}개</span>
          <span>찜 목록: {favorites.length}개</span>
        </div>
      </header>
      
      <div className="search-section">
        <input
          type="text"
          placeholder="상품 검색..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>
      
      <div className="products-grid">
        {filteredProducts.map(product => (
          <ProductCard
            key={product.id}
            product={product}
            onAddToCart={addToCart} // 함수가 메모이제이션되어 있어서 리렌더링 안됨
            onToggleFavorite={toggleFavorite}
          />
        ))}
      </div>
    </div>
  );
};
```

**성능 최적화 핵심 포인트:**
- ✅ **useMemo**: 비싼 계산 결과를 캐싱
- ✅ **useCallback**: 함수를 메모이제이션해서 자식 컴포넌트 최적화
- ✅ **React.memo**: props가 변경되지 않으면 리렌더링 방지
- ⚠️ **남용 주의**: 모든 곳에 사용하면 오히려 성능 저하

---

## 🎨 Custom Hooks: 로직 재사용의 마법

### 기본 Custom Hook

```tsx
// 😍 로컬 스토리지와 연동되는 상태 관리 Hook
import { useState, useEffect } from 'react';

function useLocalStorage<T>(key: string, initialValue: T) {
  // 로컬 스토리지에서 초기값 가져오기
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`로컬 스토리지 읽기 오류:`, error);
      return initialValue;
    }
  });

  // 값을 설정하고 로컬 스토리지에 저장
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`로컬 스토리지 저장 오류:`, error);
    }
  };

  return [storedValue, setValue] as const;
}

// 사용 예시
const UserPreferences: React.FC = () => {
  const [theme, setTheme] = useLocalStorage<'light' | 'dark'>('theme', 'light');
  const [language, setLanguage] = useLocalStorage<'ko' | 'en'>('language', 'ko');
  const [fontSize, setFontSize] = useLocalStorage<number>('fontSize', 16);

  return (
    <div className={`preferences ${theme}`}>
      <h2>사용자 설정</h2>
      
      <div className="setting">
        <label>테마:</label>
        <select value={theme} onChange={(e) => setTheme(e.target.value as 'light' | 'dark')}>
          <option value="light">라이트</option>
          <option value="dark">다크</option>
        </select>
      </div>
      
      <div className="setting">
        <label>언어:</label>
        <select value={language} onChange={(e) => setLanguage(e.target.value as 'ko' | 'en')}>
          <option value="ko">한국어</option>
          <option value="en">English</option>
        </select>
      </div>
      
      <div className="setting">
        <label>글꼴 크기:</label>
        <input 
          type="range" 
          min="12" 
          max="24" 
          value={fontSize}
          onChange={(e) => setFontSize(Number(e.target.value))}
        />
        <span>{fontSize}px</span>
      </div>
    </div>
  );
};
```

### 실전 API 페칭 Hook

```tsx
import { useState, useEffect, useCallback } from 'react';

interface FetchState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

interface UseFetchOptions {
  immediate?: boolean; // 즉시 실행 여부
  refetchInterval?: number; // 자동 새로고침 간격(ms)
}

function useFetch<T>(
  url: string,
  options: UseFetchOptions = {}
) {
  const { immediate = true, refetchInterval } = options;
  
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    loading: immediate,
    error: null
  });

  const fetchData = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setState({ data, loading: false, error: null });
      
    } catch (error) {
      setState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : '알 수 없는 오류'
      });
    }
  }, [url]);

  // 수동 새로고침 함수
  const refetch = useCallback(() => {
    fetchData();
  }, [fetchData]);

  // 초기 로딩
  useEffect(() => {
    if (immediate) {
      fetchData();
    }
  }, [fetchData, immediate]);

  // 자동 새로고침
  useEffect(() => {
    if (refetchInterval && refetchInterval > 0) {
      const intervalId = setInterval(fetchData, refetchInterval);
      return () => clearInterval(intervalId);
    }
  }, [fetchData, refetchInterval]);

  return {
    ...state,
    refetch
  };
}

// 사용 예시
interface Todo {
  id: number;
  title: string;
  completed: boolean;
}

const TodoList: React.FC = () => {
  const { data: todos, loading, error, refetch } = useFetch<Todo[]>(
    'https://jsonplaceholder.typicode.com/todos',
    {
      immediate: true,
      refetchInterval: 30000 // 30초마다 새로고침
    }
  );

  if (loading) return <div className="loading">할 일 목록을 불러오는 중...</div>;
  if (error) return <div className="error">오류: {error}</div>;

  return (
    <div className="todo-list">
      <div className="header">
        <h1>할 일 목록</h1>
        <button onClick={refetch}>새로고침</button>
      </div>
      
      {todos && todos.slice(0, 10).map(todo => (
        <div key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
          <span>{todo.title}</span>
          {todo.completed && <span className="check">✅</span>}
        </div>
      ))}
      
      <p className="info">
        총 {todos?.length}개의 할 일 중 {todos?.filter(t => t.completed).length}개 완료
      </p>
    </div>
  );
};
```

### 폼 관리 Custom Hook

```tsx
import { useState, ChangeEvent, FormEvent } from 'react';

interface FormValidation {
  required?: boolean;
  minLength?: number;
  pattern?: RegExp;
  custom?: (value: string) => string | null;
}

interface FormField {
  value: string;
  error: string | null;
  validation?: FormValidation;
}

type FormSchema<T> = {
  [K in keyof T]: FormValidation;
};

function useForm<T extends Record<string, string>>(
  initialValues: T,
  validationSchema?: FormSchema<T>
) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});

  const validateField = (name: keyof T, value: string): string | null => {
    if (!validationSchema || !validationSchema[name]) return null;

    const rules = validationSchema[name];

    if (rules.required && !value.trim()) {
      return '필수 입력 항목입니다';
    }

    if (rules.minLength && value.length < rules.minLength) {
      return `최소 ${rules.minLength}자 이상 입력해주세요`;
    }

    if (rules.pattern && !rules.pattern.test(value)) {
      return '올바른 형식이 아닙니다';
    }

    if (rules.custom) {
      return rules.custom(value);
    }

    return null;
  };

  const setValue = (name: keyof T, value: string) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // 실시간 유효성 검사
    if (touched[name]) {
      const error = validateField(name, value);
      setErrors(prev => ({ ...prev, [name]: error }));
    }
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setValue(name as keyof T, value);
  };

  const handleBlur = (name: keyof T) => {
    setTouched(prev => ({ ...prev, [name]: true }));
    const error = validateField(name, values[name]);
    setErrors(prev => ({ ...prev, [name]: error }));
  };

  const validate = (): boolean => {
    const newErrors: Partial<Record<keyof T, string>> = {};
    let isValid = true;

    Object.keys(values).forEach(key => {
      const error = validateField(key as keyof T, values[key as keyof T]);
      if (error) {
        newErrors[key as keyof T] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    setValue,
    validate,
    reset,
    isValid: Object.values(errors).every(error => !error)
  };
}

// 사용 예시
interface ContactForm {
  name: string;
  email: string;
  message: string;
}

const ContactPage: React.FC = () => {
  const form = useForm<ContactForm>(
    {
      name: '',
      email: '',
      message: ''
    },
    {
      name: {
        required: true,
        minLength: 2
      },
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        custom: (value) => {
          if (value.includes('test')) {
            return '테스트 이메일은 사용할 수 없습니다';
          }
          return null;
        }
      },
      message: {
        required: true,
        minLength: 10
      }
    }
  );

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    
    if (form.validate()) {
      console.log('폼 제출:', form.values);
      alert('메시지가 전송되었습니다!');
      form.reset();
    }
  };

  return (
    <div className="contact-page">
      <h1>문의하기</h1>
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label>이름:</label>
          <input
            name="name"
            value={form.values.name}
            onChange={form.handleChange}
            onBlur={() => form.handleBlur('name')}
            className={form.errors.name ? 'error' : ''}
          />
          {form.errors.name && <span className="error-message">{form.errors.name}</span>}
        </div>

        <div className="form-group">
          <label>이메일:</label>
          <input
            name="email"
            type="email"
            value={form.values.email}
            onChange={form.handleChange}
            onBlur={() => form.handleBlur('email')}
            className={form.errors.email ? 'error' : ''}
          />
          {form.errors.email && <span className="error-message">{form.errors.email}</span>}
        </div>

        <div className="form-group">
          <label>메시지:</label>
          <textarea
            name="message"
            value={form.values.message}
            onChange={form.handleChange}
            onBlur={() => form.handleBlur('message')}
            className={form.errors.message ? 'error' : ''}
            rows={5}
          />
          {form.errors.message && <span className="error-message">{form.errors.message}</span>}
        </div>

        <div className="form-actions">
          <button type="submit" disabled={!form.isValid}>
            전송하기
          </button>
          <button type="button" onClick={form.reset}>
            초기화
          </button>
        </div>
      </form>
    </div>
  );
};
```

---

## 🎯 종합 실습: 현대적 블로그 앱

이제 배운 모든 Hooks를 활용해서 완전한 블로그 앱을 만들어보겠습니다!

```tsx
// 📁 hooks/useBlog.ts
import { useState, useCallback } from 'react';
import { useLocalStorage } from './useLocalStorage';

interface BlogPost {
  id: number;
  title: string;
  content: string;
  author: string;
  createdAt: Date;
  updatedAt: Date;
  tags: string[];
  isPublished: boolean;
  likes: number;
}

export const useBlog = () => {
  const [posts, setPosts] = useLocalStorage<BlogPost[]>('blog-posts', []);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedTag, setSelectedTag] = useState('');
  const [sortBy, setSortBy] = useState<'date' | 'likes'>('date');

  const createPost = useCallback((postData: Omit<BlogPost, 'id' | 'createdAt' | 'updatedAt' | 'likes'>) => {
    const newPost: BlogPost = {
      ...postData,
      id: Date.now(),
      createdAt: new Date(),
      updatedAt: new Date(),
      likes: 0
    };
    
    setPosts(prev => [newPost, ...prev]);
    return newPost.id;
  }, [setPosts]);

  const updatePost = useCallback((id: number, updates: Partial<BlogPost>) => {
    setPosts(prev => prev.map(post => 
      post.id === id 
        ? { ...post, ...updates, updatedAt: new Date() }
        : post
    ));
  }, [setPosts]);

  const deletePost = useCallback((id: number) => {
    setPosts(prev => prev.filter(post => post.id !== id));
  }, [setPosts]);

  const likePost = useCallback((id: number) => {
    setPosts(prev => prev.map(post =>
      post.id === id 
        ? { ...post, likes: post.likes + 1 }
        : post
    ));
  }, [setPosts]);

  // 필터링 및 정렬된 포스트
  const filteredPosts = useMemo(() => {
    let filtered = posts.filter(post => post.isPublished);
    
    if (searchTerm) {
      filtered = filtered.filter(post =>
        post.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
        post.content.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    if (selectedTag) {
      filtered = filtered.filter(post => post.tags.includes(selectedTag));
    }
    
    filtered.sort((a, b) => {
      if (sortBy === 'date') {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      } else {
        return b.likes - a.likes;
      }
    });
    
    return filtered;
  }, [posts, searchTerm, selectedTag, sortBy]);

  const allTags = useMemo(() => {
    const tagSet = new Set<string>();
    posts.forEach(post => post.tags.forEach(tag => tagSet.add(tag)));
    return Array.from(tagSet).sort();
  }, [posts]);

  return {
    posts: filteredPosts,
    allPosts: posts,
    searchTerm,
    setSearchTerm,
    selectedTag,
    setSelectedTag,
    sortBy,
    setSortBy,
    allTags,
    createPost,
    updatePost,
    deletePost,
    likePost
  };
};

// 📁 components/BlogApp.tsx
const BlogApp: React.FC = () => {
  const blog = useBlog();
  const [currentView, setCurrentView] = useState<'list' | 'create' | 'edit'>('list');
  const [editingPost, setEditingPost] = useState<BlogPost | null>(null);

  return (
    <div className="blog-app">
      <header className="blog-header">
        <h1>📝 내 블로그</h1>
        <nav>
          <button 
            onClick={() => setCurrentView('list')}
            className={currentView === 'list' ? 'active' : ''}
          >
            포스트 목록
          </button>
          <button 
            onClick={() => setCurrentView('create')}
            className={currentView === 'create' ? 'active' : ''}
          >
            새 포스트 작성
          </button>
        </nav>
      </header>

      <main className="blog-content">
        {currentView === 'list' && (
          <BlogPostList 
            {...blog}
            onEdit={(post) => {
              setEditingPost(post);
              setCurrentView('edit');
            }}
          />
        )}
        
        {currentView === 'create' && (
          <PostEditor 
            onSave={(postData) => {
              blog.createPost(postData);
              setCurrentView('list');
            }}
            onCancel={() => setCurrentView('list')}
          />
        )}
        
        {currentView === 'edit' && editingPost && (
          <PostEditor 
            post={editingPost}
            onSave={(postData) => {
              blog.updatePost(editingPost.id, postData);
              setCurrentView('list');
              setEditingPost(null);
            }}
            onCancel={() => {
              setCurrentView('list');
              setEditingPost(null);
            }}
          />
        )}
      </main>
    </div>
  );
};
```

**실습 과제:**
1. `useReducer`를 사용해서 복잡한 상태 로직을 관리해보세요
2. `useRef`를 사용해서 포커스 관리를 해보세요
3. 댓글 기능을 추가해서 중첩 상태를 관리해보세요

---

## ✅ 체크포인트

이 강의를 완료했다면 다음을 할 수 있어야 합니다:

- [ ] Class Component와 Hooks의 차이점 설명
- [ ] useState로 다양한 타입의 상태 관리
- [ ] useEffect로 생명주기와 사이드 이펙트 처리
- [ ] useContext로 전역 상태 관리
- [ ] useMemo, useCallback으로 성능 최적화
- [ ] Custom Hooks로 로직 재사용

## 💡 핵심 정리

1. **Hooks는 함수형 프로그래밍의 력**
   - 로직 재사용이 쉬움
   - 관심사 분리가 자연스러움
   - 테스트하기 용이함

2. **성능 최적화는 필요할 때만**
   - premature optimization을 피하세요
   - 실제 성능 문제가 있을 때 최적화
   - React DevTools Profiler 활용

3. **Custom Hooks는 로직 분리의 핵심**
   - 재사용 가능한 로직을 추출
   - 컴포넌트를 깔끔하게 유지
   - 테스트와 유지보수가 쉬워짐

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Phase 2 \uac15\uc758 4\uac1c \uc81c\uc791", "status": "in_progress", "activeForm": "Phase 2 \uac15\uc758 4\uac1c \uc81c\uc791 \uc911"}, {"content": "4\uac15: React Hooks \ub9c8\uc2a4\ud130 \uc791\uc131", "status": "completed", "activeForm": "4\uac15: React Hooks \ub9c8\uc2a4\ud130 \uc791\uc131 \uc911"}, {"content": "5\uac15: \ubaa8\ub358 \uc0c1\ud0dc \uad00\ub9ac \uc791\uc131", "status": "in_progress", "activeForm": "5\uac15: \ubaa8\ub358 \uc0c1\ud0dc \uad00\ub9ac \uc791\uc131 \uc911"}, {"content": "6\uac15: \uc2a4\ud0c0\uc77c\ub9c1 & UI \uc791\uc131", "status": "pending", "activeForm": "6\uac15: \uc2a4\ud0c0\uc77c\ub9c1 & UI \uc791\uc131 \uc911"}]