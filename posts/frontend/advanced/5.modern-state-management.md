# 5강: 모던 상태 관리 - Zustand와 패턴들

## 🎯 학습 목표
- Redux의 복잡함과 Zustand의 간단함을 비교할 수 있다
- Zustand로 전역 상태를 효율적으로 관리할 수 있다
- Context API와 상태 관리 라이브러리의 차이점을 이해한다
- Props Drilling 문제를 완전히 해결할 수 있다
- Container/Presentational 패턴을 활용할 수 있다

---

## 🤔 왜 Redux 대신 Zustand를 써야 할까?

### Redux의 복잡함

```javascript
// 😢 Redux - 너무 많은 보일러플레이트 코드
// 1. Actions
const INCREMENT = 'counter/increment';
const DECREMENT = 'counter/decrement';
const SET_USER = 'user/setUser';

const increment = () => ({ type: INCREMENT });
const decrement = () => ({ type: DECREMENT });
const setUser = (user) => ({ type: SET_USER, payload: user });

// 2. Reducers
const initialState = {
  counter: {
    value: 0
  },
  user: {
    name: '',
    email: ''
  }
};

function counterReducer(state = initialState.counter, action) {
  switch (action.type) {
    case INCREMENT:
      return { ...state, value: state.value + 1 };
    case DECREMENT:
      return { ...state, value: state.value - 1 };
    default:
      return state;
  }
}

function userReducer(state = initialState.user, action) {
  switch (action.type) {
    case SET_USER:
      return { ...state, ...action.payload };
    default:
      return state;
  }
}

// 3. Store 설정
import { createStore, combineReducers } from 'redux';
const rootReducer = combineReducers({
  counter: counterReducer,
  user: userReducer
});
const store = createStore(rootReducer);

// 4. 컴포넌트에서 사용
import { useSelector, useDispatch } from 'react-redux';

const Counter = () => {
  const count = useSelector(state => state.counter.value);
  const dispatch = useDispatch();
  
  return (
    <div>
      <span>{count}</span>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
};
```

**Redux의 문제점:**
- 📝 **너무 많은 코드**: 간단한 상태 하나에도 수십 줄
- 🔄 **복잡한 플로우**: Action → Reducer → Store → Component
- 🧩 **파일 분산**: actions, reducers, selectors 등 여러 파일
- 📚 **학습 곡선**: 초보자가 이해하기 어려움

### Zustand의 간단함

```tsx
// 😍 Zustand - 단순하고 직관적
import { create } from 'zustand';

interface AppState {
  // 카운터 상태
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
  
  // 사용자 상태
  user: {
    name: string;
    email: string;
  } | null;
  setUser: (user: { name: string; email: string }) => void;
  logout: () => void;
  
  // UI 상태
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

// 😍 하나의 스토어에서 모든 상태와 액션 관리
const useAppStore = create<AppState>((set, get) => ({
  // 카운터
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  
  // 사용자
  user: null,
  setUser: (user) => set({ user }),
  logout: () => set({ user: null }),
  
  // 테마
  theme: 'light',
  toggleTheme: () => set((state) => ({ 
    theme: state.theme === 'light' ? 'dark' : 'light' 
  }))
}));

// 😍 컴포넌트에서 간단하게 사용
const Counter: React.FC = () => {
  const { count, increment, decrement, reset } = useAppStore();
  
  return (
    <div className="counter">
      <h2>카운터: {count}</h2>
      <div className="buttons">
        <button onClick={increment}>+1</button>
        <button onClick={decrement}>-1</button>
        <button onClick={reset}>리셋</button>
      </div>
    </div>
  );
};

const UserProfile: React.FC = () => {
  const { user, setUser, logout } = useAppStore();
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  
  const handleLogin = (e: React.FormEvent) => {
    e.preventDefault();
    if (name && email) {
      setUser({ name, email });
      setName('');
      setEmail('');
    }
  };
  
  if (user) {
    return (
      <div className="user-profile">
        <h3>환영합니다, {user.name}님!</h3>
        <p>이메일: {user.email}</p>
        <button onClick={logout}>로그아웃</button>
      </div>
    );
  }
  
  return (
    <form onSubmit={handleLogin} className="login-form">
      <h3>로그인</h3>
      <input
        type="text"
        placeholder="이름"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <input
        type="email"
        placeholder="이메일"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit">로그인</button>
    </form>
  );
};
```

**Zustand의 장점:**
- ✅ **간단한 API**: create 함수 하나로 스토어 생성
- ✅ **적은 코드**: Redux 대비 80% 코드 감소
- ✅ **TypeScript 친화적**: 완벽한 타입 지원
- ✅ **성능 최적화**: 필요한 상태만 구독
- ✅ **학습 곡선**: 5분이면 익힐 수 있음

---

## 🏪 Zustand 완전 활용법

### 기본 스토어 구조

```tsx
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
  createdAt: Date;
}

interface Filter {
  status: 'all' | 'active' | 'completed';
  search: string;
}

interface TodoState {
  // 상태
  todos: Todo[];
  filter: Filter;
  
  // 액션
  addTodo: (text: string) => void;
  toggleTodo: (id: number) => void;
  deleteTodo: (id: number) => void;
  updateTodo: (id: number, text: string) => void;
  clearCompleted: () => void;
  
  // 필터
  setFilter: (filter: Partial<Filter>) => void;
  
  // 계산된 값들
  filteredTodos: Todo[];
  stats: {
    total: number;
    active: number;
    completed: number;
  };
}

export const useTodoStore = create<TodoState>()(
  persist(
    (set, get) => ({
      // 초기 상태
      todos: [],
      filter: { status: 'all', search: '' },
      
      // 할일 관리 액션
      addTodo: (text) => {
        const newTodo: Todo = {
          id: Date.now(),
          text: text.trim(),
          completed: false,
          createdAt: new Date()
        };
        set((state) => ({
          todos: [newTodo, ...state.todos]
        }));
      },
      
      toggleTodo: (id) => set((state) => ({
        todos: state.todos.map(todo =>
          todo.id === id ? { ...todo, completed: !todo.completed } : todo
        )
      })),
      
      deleteTodo: (id) => set((state) => ({
        todos: state.todos.filter(todo => todo.id !== id)
      })),
      
      updateTodo: (id, text) => set((state) => ({
        todos: state.todos.map(todo =>
          todo.id === id ? { ...todo, text: text.trim() } : todo
        )
      })),
      
      clearCompleted: () => set((state) => ({
        todos: state.todos.filter(todo => !todo.completed)
      })),
      
      // 필터 액션
      setFilter: (newFilter) => set((state) => ({
        filter: { ...state.filter, ...newFilter }
      })),
      
      // 😍 계산된 값들 - getter 형태로 구현
      get filteredTodos() {
        const { todos, filter } = get();
        let filtered = todos;
        
        // 상태 필터링
        if (filter.status === 'active') {
          filtered = filtered.filter(todo => !todo.completed);
        } else if (filter.status === 'completed') {
          filtered = filtered.filter(todo => todo.completed);
        }
        
        // 검색 필터링
        if (filter.search) {
          filtered = filtered.filter(todo =>
            todo.text.toLowerCase().includes(filter.search.toLowerCase())
          );
        }
        
        return filtered;
      },
      
      get stats() {
        const { todos } = get();
        return {
          total: todos.length,
          active: todos.filter(todo => !todo.completed).length,
          completed: todos.filter(todo => todo.completed).length
        };
      }
    }),
    {
      name: 'todo-storage', // 로컬스토리지 키
      storage: createJSONStorage(() => localStorage),
      // Date 객체 직렬화 문제 해결
      serialize: (state) => JSON.stringify(state, (key, value) => {
        if (key === 'createdAt' && value instanceof Date) {
          return value.toISOString();
        }
        return value;
      }),
      deserialize: (str) => {
        const parsed = JSON.parse(str);
        // Date 객체 복원
        if (parsed.state?.todos) {
          parsed.state.todos = parsed.state.todos.map((todo: any) => ({
            ...todo,
            createdAt: new Date(todo.createdAt)
          }));
        }
        return parsed;
      }
    }
  )
);
```

### 컴포넌트에서 선택적 구독

```tsx
// 😍 필요한 상태만 구독해서 성능 최적화
const TodoApp: React.FC = () => {
  // 각 컴포넌트는 필요한 상태만 구독
  const addTodo = useTodoStore((state) => state.addTodo);
  const filter = useTodoStore((state) => state.filter);
  const setFilter = useTodoStore((state) => state.setFilter);
  
  const [inputText, setInputText] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (inputText.trim()) {
      addTodo(inputText);
      setInputText('');
    }
  };
  
  return (
    <div className="todo-app">
      <header className="todo-header">
        <h1>📝 할일 관리</h1>
        
        {/* 새 할일 입력 */}
        <form onSubmit={handleSubmit} className="add-todo-form">
          <input
            type="text"
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            placeholder="새 할일을 입력하세요..."
            className="add-todo-input"
          />
          <button type="submit" disabled={!inputText.trim()}>
            추가
          </button>
        </form>
        
        {/* 필터 및 검색 */}
        <div className="filters">
          <div className="status-filter">
            <button
              className={filter.status === 'all' ? 'active' : ''}
              onClick={() => setFilter({ status: 'all' })}
            >
              전체
            </button>
            <button
              className={filter.status === 'active' ? 'active' : ''}
              onClick={() => setFilter({ status: 'active' })}
            >
              진행중
            </button>
            <button
              className={filter.status === 'completed' ? 'active' : ''}
              onClick={() => setFilter({ status: 'completed' })}
            >
              완료됨
            </button>
          </div>
          
          <input
            type="text"
            placeholder="할일 검색..."
            value={filter.search}
            onChange={(e) => setFilter({ search: e.target.value })}
            className="search-input"
          />
        </div>
      </header>
      
      <main>
        <TodoList />
        <TodoStats />
      </main>
    </div>
  );
};

// 😍 각 컴포넌트가 독립적으로 상태 구독
const TodoList: React.FC = () => {
  const filteredTodos = useTodoStore((state) => state.filteredTodos);
  const toggleTodo = useTodoStore((state) => state.toggleTodo);
  const deleteTodo = useTodoStore((state) => state.deleteTodo);
  
  if (filteredTodos.length === 0) {
    return (
      <div className="empty-state">
        <p>할일이 없습니다. 새로운 할일을 추가해보세요! 📝</p>
      </div>
    );
  }
  
  return (
    <ul className="todo-list">
      {filteredTodos.map((todo) => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={() => toggleTodo(todo.id)}
          onDelete={() => deleteTodo(todo.id)}
        />
      ))}
    </ul>
  );
};

const TodoItem: React.FC<{
  todo: Todo;
  onToggle: () => void;
  onDelete: () => void;
}> = ({ todo, onToggle, onDelete }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);
  const updateTodo = useTodoStore((state) => state.updateTodo);
  
  const handleSave = () => {
    if (editText.trim() && editText !== todo.text) {
      updateTodo(todo.id, editText);
    }
    setIsEditing(false);
  };
  
  const handleCancel = () => {
    setEditText(todo.text);
    setIsEditing(false);
  };
  
  return (
    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
        className="todo-checkbox"
      />
      
      {isEditing ? (
        <div className="todo-edit">
          <input
            type="text"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleSave();
              if (e.key === 'Escape') handleCancel();
            }}
            autoFocus
          />
          <button onClick={handleSave}>저장</button>
          <button onClick={handleCancel}>취소</button>
        </div>
      ) : (
        <div className="todo-content">
          <span className="todo-text" onDoubleClick={() => setIsEditing(true)}>
            {todo.text}
          </span>
          <small className="todo-date">
            {todo.createdAt.toLocaleDateString('ko-KR')}
          </small>
        </div>
      )}
      
      <div className="todo-actions">
        {!isEditing && (
          <>
            <button onClick={() => setIsEditing(true)}>수정</button>
            <button onClick={onDelete} className="delete-btn">삭제</button>
          </>
        )}
      </div>
    </li>
  );
};

const TodoStats: React.FC = () => {
  const stats = useTodoStore((state) => state.stats);
  const clearCompleted = useTodoStore((state) => state.clearCompleted);
  
  return (
    <div className="todo-stats">
      <div className="stats-info">
        <span>전체: {stats.total}개</span>
        <span>진행중: {stats.active}개</span>
        <span>완료: {stats.completed}개</span>
      </div>
      
      {stats.completed > 0 && (
        <button onClick={clearCompleted} className="clear-completed">
          완료된 항목 삭제 ({stats.completed}개)
        </button>
      )}
      
      {stats.total > 0 && (
        <div className="progress-bar">
          <div 
            className="progress-fill"
            style={{ 
              width: `${(stats.completed / stats.total) * 100}%` 
            }}
          />
          <span className="progress-text">
            {Math.round((stats.completed / stats.total) * 100)}% 완료
          </span>
        </div>
      )}
    </div>
  );
};
```

---

## 🆚 Context API vs Zustand 비교

### Context API의 한계

```tsx
// 😢 Context API - Provider 지옥과 성능 문제
const ThemeContext = createContext();
const UserContext = createContext();
const NotificationContext = createContext();
const ShoppingCartContext = createContext();

function App() {
  return (
    <ThemeProvider>
      <UserProvider>
        <NotificationProvider>
          <ShoppingCartProvider>
            <Router>
              <Routes>
                <Route path="/" element={<HomePage />} />
              </Routes>
            </Router>
          </ShoppingCartProvider>
        </NotificationProvider>
      </UserProvider>
    </ThemeProvider>
  );
}

// 모든 상태가 바뀔 때마다 전체 하위 트리가 리렌더링됨
const UserProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [notifications, setNotifications] = useState([]);
  
  // user가 바뀌면 theme과 notifications를 사용하는 컴포넌트도 리렌더링
  return (
    <UserContext.Provider value={{ user, setUser, theme, setTheme, notifications, setNotifications }}>
      {children}
    </UserContext.Provider>
  );
};
```

### Zustand의 우월성

```tsx
// 😍 Zustand - 깔끔하고 효율적
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface AppStore {
  // 테마 관리
  theme: 'light' | 'dark';
  toggleTheme: () => void;
  
  // 사용자 관리
  user: User | null;
  login: (user: User) => void;
  logout: () => void;
  
  // 알림 관리
  notifications: Notification[];
  addNotification: (notification: Omit<Notification, 'id'>) => void;
  removeNotification: (id: string) => void;
  
  // 쇼핑카트 관리
  cart: CartItem[];
  addToCart: (product: Product) => void;
  removeFromCart: (productId: number) => void;
  updateQuantity: (productId: number, quantity: number) => void;
}

const useAppStore = create<AppStore>()(
  subscribeWithSelector((set, get) => ({
    // 테마
    theme: 'light',
    toggleTheme: () => set((state) => ({ 
      theme: state.theme === 'light' ? 'dark' : 'light' 
    })),
    
    // 사용자
    user: null,
    login: (user) => {
      set({ user });
      // 로그인시 환영 알림 추가
      get().addNotification({
        type: 'success',
        title: '로그인 성공',
        message: `환영합니다, ${user.name}님!`
      });
    },
    logout: () => {
      set({ user: null, cart: [] }); // 로그아웃시 카트도 비우기
      get().addNotification({
        type: 'info',
        title: '로그아웃',
        message: '안전하게 로그아웃되었습니다.'
      });
    },
    
    // 알림
    notifications: [],
    addNotification: (notification) => {
      const newNotification = {
        ...notification,
        id: Date.now().toString(),
        timestamp: new Date()
      };
      set((state) => ({ 
        notifications: [newNotification, ...state.notifications] 
      }));
      
      // 5초 후 자동 제거
      setTimeout(() => {
        get().removeNotification(newNotification.id);
      }, 5000);
    },
    removeNotification: (id) => set((state) => ({
      notifications: state.notifications.filter(n => n.id !== id)
    })),
    
    // 쇼핑카트
    cart: [],
    addToCart: (product) => {
      set((state) => {
        const existingItem = state.cart.find(item => item.productId === product.id);
        if (existingItem) {
          return {
            cart: state.cart.map(item =>
              item.productId === product.id
                ? { ...item, quantity: item.quantity + 1 }
                : item
            )
          };
        } else {
          return {
            cart: [...state.cart, { 
              productId: product.id, 
              product, 
              quantity: 1 
            }]
          };
        }
      });
      
      get().addNotification({
        type: 'success',
        title: '상품 추가됨',
        message: `${product.name}이(가) 장바구니에 추가되었습니다.`
      });
    },
    
    removeFromCart: (productId) => set((state) => ({
      cart: state.cart.filter(item => item.productId !== productId)
    })),
    
    updateQuantity: (productId, quantity) => set((state) => ({
      cart: quantity > 0 
        ? state.cart.map(item =>
            item.productId === productId 
              ? { ...item, quantity }
              : item
          )
        : state.cart.filter(item => item.productId !== productId)
    }))
  }))
);

// 😍 컴포넌트에서 필요한 상태만 선택적 구독
const Header: React.FC = () => {
  // 테마 상태가 변경될 때만 리렌더링
  const theme = useAppStore((state) => state.theme);
  const toggleTheme = useAppStore((state) => state.toggleTheme);
  
  return (
    <header className={`header ${theme}`}>
      <button onClick={toggleTheme}>
        {theme === 'light' ? '🌙' : '☀️'}
      </button>
      <UserMenu />
      <CartIcon />
    </header>
  );
};

const UserMenu: React.FC = () => {
  // 사용자 상태가 변경될 때만 리렌더링
  const user = useAppStore((state) => state.user);
  const logout = useAppStore((state) => state.logout);
  
  if (!user) {
    return <LoginButton />;
  }
  
  return (
    <div className="user-menu">
      <span>안녕하세요, {user.name}님!</span>
      <button onClick={logout}>로그아웃</button>
    </div>
  );
};

const CartIcon: React.FC = () => {
  // 카트 아이템 개수만 구독 (효율적!)
  const itemCount = useAppStore((state) => 
    state.cart.reduce((sum, item) => sum + item.quantity, 0)
  );
  
  return (
    <div className="cart-icon">
      🛒 
      {itemCount > 0 && <span className="badge">{itemCount}</span>}
    </div>
  );
};
```

**Context API vs Zustand 비교표:**

| 특성 | Context API | Zustand |
|------|-------------|---------|
| **설정 복잡도** | 높음 (Provider 지옥) | 낮음 (create 함수 하나) |
| **성능** | 낮음 (불필요한 리렌더링) | 높음 (선택적 구독) |
| **TypeScript 지원** | 복잡함 | 완벽함 |
| **개발자 도구** | 기본 제공 안됨 | Redux DevTools 호환 |
| **번들 크기** | 0 (React 내장) | 9.7kb |
| **학습 곡선** | 보통 | 매우 쉬움 |
| **상태 지속성** | 직접 구현 | 미들웨어로 제공 |

---

## 🎯 고급 패턴: Container/Presentational

### Presentational Components (멍청한 컴포넌트)

```tsx
// 😍 순수한 UI 컴포넌트 - 상태를 모름, 재사용 가능
interface ProductCardProps {
  product: {
    id: number;
    name: string;
    price: number;
    image: string;
    inStock: boolean;
  };
  onAddToCart: () => void;
  onToggleFavorite: () => void;
  isFavorite: boolean;
  isInCart: boolean;
}

const ProductCard: React.FC<ProductCardProps> = ({
  product,
  onAddToCart,
  onToggleFavorite,
  isFavorite,
  isInCart
}) => {
  return (
    <div className="product-card">
      <div className="product-image">
        <img src={product.image} alt={product.name} />
        <button 
          className={`favorite-btn ${isFavorite ? 'active' : ''}`}
          onClick={onToggleFavorite}
        >
          {isFavorite ? '❤️' : '🤍'}
        </button>
      </div>
      
      <div className="product-info">
        <h3>{product.name}</h3>
        <p className="price">{product.price.toLocaleString()}원</p>
        
        <div className="product-status">
          {product.inStock ? (
            <span className="in-stock">재고 있음</span>
          ) : (
            <span className="out-of-stock">품절</span>
          )}
        </div>
        
        <button
          className={`add-to-cart-btn ${isInCart ? 'added' : ''}`}
          onClick={onAddToCart}
          disabled={!product.inStock}
        >
          {isInCart ? '장바구니에 담음 ✓' : '장바구니 추가'}
        </button>
      </div>
    </div>
  );
};

interface ProductListProps {
  products: Product[];
  loading: boolean;
  error: string | null;
  onAddToCart: (product: Product) => void;
  onToggleFavorite: (productId: number) => void;
  favorites: number[];
  cartItems: number[];
}

const ProductList: React.FC<ProductListProps> = ({
  products,
  loading,
  error,
  onAddToCart,
  onToggleFavorite,
  favorites,
  cartItems
}) => {
  if (loading) {
    return (
      <div className="loading-state">
        <div className="spinner" />
        <p>상품을 불러오는 중...</p>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="error-state">
        <h3>오류가 발생했습니다</h3>
        <p>{error}</p>
      </div>
    );
  }
  
  if (products.length === 0) {
    return (
      <div className="empty-state">
        <h3>상품이 없습니다</h3>
        <p>다른 카테고리를 확인해보세요.</p>
      </div>
    );
  }
  
  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={() => onAddToCart(product)}
          onToggleFavorite={() => onToggleFavorite(product.id)}
          isFavorite={favorites.includes(product.id)}
          isInCart={cartItems.includes(product.id)}
        />
      ))}
    </div>
  );
};
```

### Container Components (똑똑한 컴포넌트)

```tsx
// 😍 상태와 로직을 담당하는 컨테이너 컴포넌트
interface ShopState {
  // 상품 관리
  products: Product[];
  loading: boolean;
  error: string | null;
  fetchProducts: (category?: string) => Promise<void>;
  
  // 즐겨찾기 관리
  favorites: number[];
  toggleFavorite: (productId: number) => void;
  
  // 장바구니 관리
  cart: CartItem[];
  addToCart: (product: Product) => void;
}

const useShopStore = create<ShopState>((set, get) => ({
  // 상품 상태
  products: [],
  loading: false,
  error: null,
  
  fetchProducts: async (category) => {
    set({ loading: true, error: null });
    try {
      const response = await fetch(`/api/products${category ? `?category=${category}` : ''}`);
      if (!response.ok) {
        throw new Error('상품을 불러오는데 실패했습니다');
      }
      const products = await response.json();
      set({ products, loading: false });
    } catch (error) {
      set({ 
        products: [], 
        loading: false, 
        error: error instanceof Error ? error.message : '알 수 없는 오류' 
      });
    }
  },
  
  // 즐겨찾기
  favorites: [],
  toggleFavorite: (productId) => set((state) => ({
    favorites: state.favorites.includes(productId)
      ? state.favorites.filter(id => id !== productId)
      : [...state.favorites, productId]
  })),
  
  // 장바구니
  cart: [],
  addToCart: (product) => {
    set((state) => {
      const existingItem = state.cart.find(item => item.product.id === product.id);
      if (existingItem) {
        return {
          cart: state.cart.map(item =>
            item.product.id === product.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      } else {
        return {
          cart: [...state.cart, { product, quantity: 1 }]
        };
      }
    });
  }
}));

// 😍 Container Component - 상태와 로직 관리
const ProductListContainer: React.FC<{ category?: string }> = ({ category }) => {
  const {
    products,
    loading,
    error,
    favorites,
    cart,
    fetchProducts,
    toggleFavorite,
    addToCart
  } = useShopStore();
  
  // 카테고리 변경시 상품 다시 로딩
  useEffect(() => {
    fetchProducts(category);
  }, [category, fetchProducts]);
  
  // 장바구니에 있는 상품 ID 목록 계산
  const cartProductIds = useMemo(() => 
    cart.map(item => item.product.id),
    [cart]
  );
  
  // 😍 Presentational 컴포넌트에 props 전달
  return (
    <ProductList
      products={products}
      loading={loading}
      error={error}
      onAddToCart={addToCart}
      onToggleFavorite={toggleFavorite}
      favorites={favorites}
      cartItems={cartProductIds}
    />
  );
};

// 😍 최종 사용
const ShopPage: React.FC = () => {
  const [selectedCategory, setSelectedCategory] = useState<string>('');
  
  return (
    <div className="shop-page">
      <header>
        <h1>온라인 스토어</h1>
        <CategoryFilter 
          selectedCategory={selectedCategory}
          onSelectCategory={setSelectedCategory}
        />
      </header>
      
      <main>
        <ProductListContainer category={selectedCategory} />
      </main>
    </div>
  );
};
```

**Container/Presentational 패턴의 장점:**
- ✅ **관심사 분리**: UI와 로직이 명확히 분리
- ✅ **재사용성**: Presentational 컴포넌트는 어디서든 재사용 가능
- ✅ **테스트 용이**: UI와 로직을 독립적으로 테스트
- ✅ **협업 효율**: 디자이너는 UI, 개발자는 로직에 집중

---

## 🚀 실전 프로젝트: 전자상거래 앱

이제 모든 패턴을 활용해서 실제 전자상거래 앱을 만들어보겠습니다!

```tsx
// 📁 stores/useEcommerceStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface Product {
  id: number;
  name: string;
  price: number;
  image: string;
  category: string;
  description: string;
  inStock: boolean;
  rating: number;
}

interface CartItem {
  product: Product;
  quantity: number;
}

interface User {
  id: number;
  name: string;
  email: string;
  address?: string;
}

interface EcommerceState {
  // 사용자 관리
  user: User | null;
  login: (user: User) => void;
  logout: () => void;
  
  // 상품 관리
  products: Product[];
  searchTerm: string;
  selectedCategory: string;
  loading: boolean;
  error: string | null;
  
  // 상품 액션
  setProducts: (products: Product[]) => void;
  setSearchTerm: (term: string) => void;
  setSelectedCategory: (category: string) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  
  // 장바구니 관리
  cart: CartItem[];
  addToCart: (product: Product, quantity?: number) => void;
  removeFromCart: (productId: number) => void;
  updateQuantity: (productId: number, quantity: number) => void;
  clearCart: () => void;
  
  // 즐겨찾기
  favorites: number[];
  toggleFavorite: (productId: number) => void;
  
  // 주문 관리
  orders: Order[];
  createOrder: (orderData: Omit<Order, 'id' | 'createdAt'>) => void;
  
  // 계산된 값들
  get filteredProducts(): Product[];
  get cartTotal(): number;
  get cartItemCount(): number;
}

export const useEcommerceStore = create<EcommerceState>()(
  persist(
    (set, get) => ({
      // 사용자
      user: null,
      login: (user) => set({ user }),
      logout: () => set({ user: null, cart: [], orders: [] }),
      
      // 상품
      products: [],
      searchTerm: '',
      selectedCategory: '',
      loading: false,
      error: null,
      
      setProducts: (products) => set({ products, loading: false, error: null }),
      setSearchTerm: (searchTerm) => set({ searchTerm }),
      setSelectedCategory: (selectedCategory) => set({ selectedCategory }),
      setLoading: (loading) => set({ loading }),
      setError: (error) => set({ error, loading: false }),
      
      // 장바구니
      cart: [],
      addToCart: (product, quantity = 1) => {
        set((state) => {
          const existingItem = state.cart.find(item => item.product.id === product.id);
          if (existingItem) {
            return {
              cart: state.cart.map(item =>
                item.product.id === product.id
                  ? { ...item, quantity: item.quantity + quantity }
                  : item
              )
            };
          } else {
            return {
              cart: [...state.cart, { product, quantity }]
            };
          }
        });
      },
      
      removeFromCart: (productId) => set((state) => ({
        cart: state.cart.filter(item => item.product.id !== productId)
      })),
      
      updateQuantity: (productId, quantity) => {
        if (quantity <= 0) {
          get().removeFromCart(productId);
          return;
        }
        
        set((state) => ({
          cart: state.cart.map(item =>
            item.product.id === productId
              ? { ...item, quantity }
              : item
          )
        }));
      },
      
      clearCart: () => set({ cart: [] }),
      
      // 즐겨찾기
      favorites: [],
      toggleFavorite: (productId) => set((state) => ({
        favorites: state.favorites.includes(productId)
          ? state.favorites.filter(id => id !== productId)
          : [...state.favorites, productId]
      })),
      
      // 주문
      orders: [],
      createOrder: (orderData) => {
        const newOrder = {
          ...orderData,
          id: Date.now(),
          createdAt: new Date()
        };
        set((state) => ({
          orders: [newOrder, ...state.orders],
          cart: [] // 주문 후 장바구니 비우기
        }));
      },
      
      // 계산된 값들
      get filteredProducts() {
        const { products, searchTerm, selectedCategory } = get();
        let filtered = products;
        
        if (selectedCategory) {
          filtered = filtered.filter(p => p.category === selectedCategory);
        }
        
        if (searchTerm) {
          filtered = filtered.filter(p =>
            p.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            p.description.toLowerCase().includes(searchTerm.toLowerCase())
          );
        }
        
        return filtered;
      },
      
      get cartTotal() {
        const { cart } = get();
        return cart.reduce((total, item) => 
          total + (item.product.price * item.quantity), 0
        );
      },
      
      get cartItemCount() {
        const { cart } = get();
        return cart.reduce((count, item) => count + item.quantity, 0);
      }
    }),
    {
      name: 'ecommerce-storage',
      storage: createJSONStorage(() => localStorage),
      // 사용자 정보와 장바구니만 저장 (상품 목록은 제외)
      partialize: (state) => ({
        user: state.user,
        cart: state.cart,
        favorites: state.favorites,
        orders: state.orders
      })
    }
  )
);

// 😍 API 호출을 위한 커스텀 훅
export const useProductApi = () => {
  const { setProducts, setLoading, setError } = useEcommerceStore();
  
  const fetchProducts = useCallback(async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/products');
      if (!response.ok) throw new Error('상품을 불러오는데 실패했습니다');
      const products = await response.json();
      setProducts(products);
    } catch (error) {
      setError(error instanceof Error ? error.message : '알 수 없는 오류');
    }
  }, [setProducts, setLoading, setError]);
  
  return { fetchProducts };
};
```

---

## ✅ 체크포인트

이 강의를 완료했다면 다음을 할 수 있어야 합니다:

- [ ] Redux와 Zustand의 차이점을 설명하고 Zustand의 장점을 활용
- [ ] Zustand로 전역 상태를 효율적으로 관리
- [ ] 선택적 구독으로 성능 최적화
- [ ] Context API vs 상태 관리 라이브러리 비교 및 적절한 선택
- [ ] Container/Presentational 패턴으로 관심사 분리
- [ ] 실전 프로젝트에서 모든 패턴 통합 활용

## 💡 핵심 정리

1. **Zustand = Redux의 간단한 대안**
   - 80% 적은 코드로 같은 기능
   - 뛰어난 TypeScript 지원
   - 선택적 구독으로 성능 최적화

2. **상태 관리 선택 기준**
   - 단순한 전역 상태 → Context API
   - 복잡한 전역 상태 → Zustand
   - 매우 복잡한 상태 → Redux Toolkit

3. **Container/Presentational 패턴**
   - UI와 로직의 완전한 분리
   - 재사용성과 테스트 용이성 극대화

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Phase 2 \uac15\uc758 4\uac1c \uc81c\uc791", "status": "in_progress", "activeForm": "Phase 2 \uac15\uc758 4\uac1c \uc81c\uc791 \uc911"}, {"content": "4\uac15: React Hooks \ub9c8\uc2a4\ud130 \uc791\uc131", "status": "completed", "activeForm": "4\uac15: React Hooks \ub9c8\uc2a4\ud130 \uc791\uc131 \uc911"}, {"content": "5\uac15: \ubaa8\ub358 \uc0c1\ud0dc \uad00\ub9ac \uc791\uc131", "status": "completed", "activeForm": "5\uac15: \ubaa8\ub358 \uc0c1\ud0dc \uad00\ub9ac \uc791\uc131 \uc911"}, {"content": "6\uac15: \uc2a4\ud0c0\uc77c\ub9c1 & UI \uc791\uc131", "status": "in_progress", "activeForm": "6\uac15: \uc2a4\ud0c0\uc77c\ub9c1 & UI \uc791\uc131 \uc911"}]