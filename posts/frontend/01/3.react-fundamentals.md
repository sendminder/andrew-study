# 3강: React 핵심 개념 완전 정복

## 🎯 학습 목표
- CSR vs SSR vs SSG 렌더링 방식을 명확히 구분할 수 있다
- JSX 문법과 컴포넌트 기반 아키텍처를 이해한다
- Props와 State의 차이점을 알고 적절히 활용할 수 있다
- 이벤트 핸들링과 조건부 렌더링을 마스터한다

---

## 🤔 React가 왜 혁신적일까?

### 기존 웹 개발의 문제점

```html
<!-- 😢 전통적인 웹 개발 - HTML, CSS, JS 분리 -->
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="user-list">
        <!-- JavaScript로 동적 생성 -->
    </div>
    <script src="script.js"></script>
</body>
</html>
```

```javascript
// 😢 복잡한 DOM 조작
const users = [
    { id: 1, name: 'Andrew', status: 'active' },
    { id: 2, name: 'Bob', status: 'inactive' }
];

function renderUsers() {
    const container = document.getElementById('user-list');
    container.innerHTML = ''; // 전체 지우고 다시 그리기
    
    users.forEach(user => {
        const div = document.createElement('div');
        div.className = `user ${user.status}`;
        div.innerHTML = `
            <h3>${user.name}</h3>
            <button onclick="toggleStatus(${user.id})">
                ${user.status === 'active' ? 'Deactivate' : 'Activate'}
            </button>
        `;
        container.appendChild(div);
    });
}

function toggleStatus(id) {
    const user = users.find(u => u.id === id);
    user.status = user.status === 'active' ? 'inactive' : 'active';
    renderUsers(); // 전체 다시 렌더링 - 비효율적!
}
```

### React의 혁신적 접근

```tsx
// 😍 React - 컴포넌트 기반, 선언적
import { useState } from 'react';

interface User {
  id: number;
  name: string;
  status: 'active' | 'inactive';
}

const UserList: React.FC = () => {
  const [users, setUsers] = useState<User[]>([
    { id: 1, name: 'Andrew', status: 'active' },
    { id: 2, name: 'Bob', status: 'inactive' }
  ]);

  const toggleStatus = (id: number) => {
    setUsers(users.map(user => 
      user.id === id 
        ? { ...user, status: user.status === 'active' ? 'inactive' : 'active' }
        : user
    ));
  };

  return (
    <div>
      {users.map(user => (
        <div key={user.id} className={`user ${user.status}`}>
          <h3>{user.name}</h3>
          <button onClick={() => toggleStatus(user.id)}>
            {user.status === 'active' ? 'Deactivate' : 'Activate'}
          </button>
        </div>
      ))}
    </div>
  );
};
```

**React의 핵심 장점:**
- 🎯 **선언적**: "어떻게"가 아닌 "무엇을" 그릴지만 정의
- 🔄 **Virtual DOM**: 변경사항만 효율적으로 업데이트
- 🧩 **컴포넌트 기반**: 재사용 가능한 UI 블록
- 🔍 **단방향 데이터 흐름**: 예측 가능한 상태 관리

---

## 🖥️ 렌더링 방식 완전 이해

### CSR (Client Side Rendering)

**어떻게 동작할까?**
```html
<!-- 서버에서 보내는 HTML - 거의 빈 껍데기 -->
<!DOCTYPE html>
<html>
<head>
    <title>My React App</title>
</head>
<body>
    <div id="root"></div>  <!-- 비어있음! -->
    <script src="/static/js/bundle.js"></script>
</body>
</html>
```

**브라우저에서:**
```
1. HTML 다운로드 (빈 화면) 
2. JavaScript 다운로드 
3. JavaScript 실행 
4. React 앱 실행
5. API 호출해서 데이터 가져오기
6. 화면에 콘텐츠 표시 ✨
```

**장단점:**
- ✅ 페이지 이동이 빠름 (SPA)
- ✅ 서버 부하 적음
- ❌ 초기 로딩 느림
- ❌ SEO 어려움
- ❌ JavaScript 비활성화시 빈 화면

**언제 사용?**
- 관리자 페이지
- 대시보드
- 로그인 후 사용하는 앱

### SSR (Server Side Rendering)

**어떻게 동작할까?**
```tsx
// Next.js 예시
export async function getServerSideProps() {
  // 서버에서 데이터를 미리 가져옴
  const users = await fetch('https://api.example.com/users').then(r => r.json());
  
  return {
    props: { users }
  };
}

const UsersPage = ({ users }) => {
  return (
    <div>
      <h1>사용자 목록</h1>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};
```

**서버에서 생성되는 HTML:**
```html
<!-- 서버에서 완성된 HTML을 보냄 -->
<!DOCTYPE html>
<html>
<head>
    <title>사용자 목록</title>
</head>
<body>
    <div>
        <h1>사용자 목록</h1>
        <div>Andrew</div>
        <div>Bob</div>
        <div>Charlie</div>
    </div>
    <script src="/static/js/bundle.js"></script>
</body>
</html>
```

**장단점:**
- ✅ 빠른 초기 로딩 (사용자가 바로 콘텐츠 확인)
- ✅ SEO 친화적
- ✅ 소셜 미디어 공유시 미리보기 정상 동작
- ❌ 서버 부하 증가
- ❌ 페이지 이동시 새로고침

**언제 사용?**
- 블로그, 뉴스 사이트
- 이커머스 상품 페이지
- 마케팅 랜딩 페이지

### SSG (Static Site Generation)

**어떻게 동작할까?**
```tsx
// Next.js 예시 - 빌드 시점에 페이지 생성
export async function getStaticProps() {
  const posts = await fetch('https://api.example.com/posts').then(r => r.json());
  
  return {
    props: { posts },
    revalidate: 3600 // 1시간마다 재생성
  };
}

export async function getStaticPaths() {
  // 미리 생성할 페이지들을 정의
  return {
    paths: [
      { params: { id: '1' } },
      { params: { id: '2' } }
    ],
    fallback: false
  };
}
```

**빌드 프로세스:**
```
1. npm run build 실행
2. 모든 데이터를 미리 가져옴
3. HTML 파일들을 사전 생성
4. CDN에 정적 파일들을 배포
5. 사용자 요청시 즉시 HTML 제공 ⚡
```

**장단점:**
- ✅ 가장 빠른 로딩 속도
- ✅ CDN 활용으로 전 세계 빠른 서비스
- ✅ 서버 부하 없음
- ✅ 뛰어난 SEO
- ❌ 실시간 데이터 반영 어려움
- ❌ 빌드 시간 증가

**언제 사용?**
- 블로그, 문서 사이트
- 포트폴리오, 회사 홈페이지
- 제품 소개 페이지

---

## 📝 JSX 완전 정복

### JSX가 뭘까?

```tsx
// 😍 JSX - JavaScript 안에 HTML 같은 문법
const Welcome = ({ name }: { name: string }) => {
  return (
    <div className="welcome">
      <h1>Hello, {name}!</h1>
      <p>Today is {new Date().toLocaleDateString()}</p>
    </div>
  );
};

// 실제로는 이렇게 변환됨
const Welcome = ({ name }) => {
  return React.createElement(
    'div',
    { className: 'welcome' },
    React.createElement('h1', null, `Hello, ${name}!`),
    React.createElement('p', null, `Today is ${new Date().toLocaleDateString()}`)
  );
};
```

### JSX 주요 문법과 규칙

```tsx
const MyComponent = () => {
  const user = { name: 'Andrew', age: 25 };
  const isLoggedIn = true;
  const items = ['Apple', 'Banana', 'Orange'];

  return (
    <div>
      {/* 1. JavaScript 표현식은 {} 안에 */}
      <h1>Welcome, {user.name}!</h1>
      <p>You are {user.age} years old.</p>

      {/* 2. 조건부 렌더링 */}
      {isLoggedIn ? (
        <button>Logout</button>
      ) : (
        <button>Login</button>
      )}

      {/* 3. 조건부 렌더링 - 단축 평가 */}
      {isLoggedIn && <p>You are logged in!</p>}

      {/* 4. 배열 렌더링 */}
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>

      {/* 5. 인라인 스타일 */}
      <div style={{
        backgroundColor: 'blue',
        color: 'white',
        padding: '10px'
      }}>
        Styled div
      </div>

      {/* 6. className 사용 (class가 아님!) */}
      <div className="my-class">Class example</div>

      {/* 7. 이벤트 핸들러 */}
      <button onClick={() => alert('Clicked!')}>
        Click me
      </button>
    </div>
  );
};
```

**JSX 규칙:**
- 반드시 하나의 부모 요소로 감싸야 함 (또는 Fragment 사용)
- `class` → `className`
- `for` → `htmlFor`
- 모든 태그는 닫혀야 함 (`<img />`, `<br />`)
- JavaScript 예약어와 충돌하는 속성은 camelCase

---

## 🎛️ Props vs State 마스터하기

### Props - 컴포넌트 간 데이터 전달

```tsx
// 😍 Props는 부모에서 자식으로 데이터를 전달하는 방법

interface UserCardProps {
  user: {
    id: number;
    name: string;
    email: string;
    avatar?: string;
  };
  showEmail?: boolean;
  onUserClick?: (userId: number) => void;
}

// 자식 컴포넌트
const UserCard: React.FC<UserCardProps> = ({ 
  user, 
  showEmail = true,  // 기본값 설정
  onUserClick 
}) => {
  const handleClick = () => {
    onUserClick?.(user.id); // optional chaining
  };

  return (
    <div className="user-card" onClick={handleClick}>
      <img 
        src={user.avatar || '/default-avatar.png'} 
        alt={`${user.name} avatar`}
      />
      <h3>{user.name}</h3>
      {showEmail && <p>{user.email}</p>}
    </div>
  );
};

// 부모 컴포넌트
const UserList: React.FC = () => {
  const users = [
    { id: 1, name: 'Andrew', email: 'andrew@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' }
  ];

  const handleUserClick = (userId: number) => {
    console.log(`User ${userId} clicked!`);
  };

  return (
    <div>
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          showEmail={true}
          onUserClick={handleUserClick}
        />
      ))}
    </div>
  );
};
```

**Props의 특징:**
- ✅ 읽기 전용 (immutable)
- ✅ 부모에서 자식으로만 전달
- ✅ 타입 안전성 (TypeScript)

### State - 컴포넌트 내부 상태

```tsx
import { useState } from 'react';

const Counter: React.FC = () => {
  // 😍 useState로 상태 관리
  const [count, setCount] = useState<number>(0);
  const [isEven, setIsEven] = useState<boolean>(true);

  const increment = () => {
    const newCount = count + 1;
    setCount(newCount);
    setIsEven(newCount % 2 === 0);
  };

  const decrement = () => {
    const newCount = count - 1;
    setCount(newCount);
    setIsEven(newCount % 2 === 0);
  };

  return (
    <div className="counter">
      <h2>Count: {count}</h2>
      <p>The number is {isEven ? 'even' : 'odd'}</p>
      
      <div className="buttons">
        <button onClick={decrement}>-</button>
        <button onClick={increment}>+</button>
      </div>

      {/* 조건부 스타일링 */}
      <div 
        className={`count-display ${isEven ? 'even' : 'odd'}`}
        style={{
          color: count > 10 ? 'red' : 'black'
        }}
      >
        {count}
      </div>
    </div>
  );
};
```

**State의 특징:**
- ✅ 변경 가능 (mutable via setState)
- ✅ 컴포넌트 내부에서 관리
- ✅ 변경시 자동 리렌더링

### Props vs State 비교

| 구분 | Props | State |
|------|-------|-------|
| **데이터 소유** | 부모 컴포넌트 | 현재 컴포넌트 |
| **변경 가능성** | 읽기 전용 | 변경 가능 |
| **전달 방향** | 부모 → 자식 | 내부에서만 사용 |
| **리렌더링** | 부모가 변경시 | setState 호출시 |

---

## 🎮 이벤트 핸들링과 조건부 렌더링

### 실전 이벤트 핸들링

```tsx
import { useState, ChangeEvent, FormEvent } from 'react';

interface FormData {
  name: string;
  email: string;
  message: string;
}

const ContactForm: React.FC = () => {
  const [formData, setFormData] = useState<FormData>({
    name: '',
    email: '',
    message: ''
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState<Partial<FormData>>({});

  // 😍 타입 안전한 이벤트 핸들러
  const handleInputChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));

    // 에러 클리어
    if (errors[name as keyof FormData]) {
      setErrors(prev => ({
        ...prev,
        [name]: undefined
      }));
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Partial<FormData> = {};

    if (!formData.name.trim()) {
      newErrors.name = '이름을 입력해주세요';
    }

    if (!formData.email.trim()) {
      newErrors.email = '이메일을 입력해주세요';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = '올바른 이메일 형식이 아닙니다';
    }

    if (!formData.message.trim()) {
      newErrors.message = '메시지를 입력해주세요';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!validateForm()) return;

    setIsSubmitting(true);
    try {
      // 가상의 API 호출
      await new Promise(resolve => setTimeout(resolve, 2000));
      alert('메시지가 전송되었습니다!');
      
      // 폼 리셋
      setFormData({ name: '', email: '', message: '' });
    } catch (error) {
      alert('전송 중 오류가 발생했습니다.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="contact-form">
      <h2>문의하기</h2>

      <div className="form-group">
        <label htmlFor="name">이름</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          className={errors.name ? 'error' : ''}
          disabled={isSubmitting}
        />
        {errors.name && <span className="error-message">{errors.name}</span>}
      </div>

      <div className="form-group">
        <label htmlFor="email">이메일</label>
        <input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
          className={errors.email ? 'error' : ''}
          disabled={isSubmitting}
        />
        {errors.email && <span className="error-message">{errors.email}</span>}
      </div>

      <div className="form-group">
        <label htmlFor="message">메시지</label>
        <textarea
          id="message"
          name="message"
          value={formData.message}
          onChange={handleInputChange}
          rows={5}
          className={errors.message ? 'error' : ''}
          disabled={isSubmitting}
        />
        {errors.message && <span className="error-message">{errors.message}</span>}
      </div>

      <button 
        type="submit" 
        disabled={isSubmitting}
        className={isSubmitting ? 'loading' : ''}
      >
        {isSubmitting ? '전송 중...' : '전송하기'}
      </button>
    </form>
  );
};
```

### 조건부 렌더링 패턴들

```tsx
const Dashboard: React.FC = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 😍 다양한 조건부 렌더링 패턴
  
  // 1. Early Return 패턴
  if (loading) {
    return (
      <div className="loading-screen">
        <div className="spinner" />
        <p>로딩 중...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="error-screen">
        <h2>오류가 발생했습니다</h2>
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>
          다시 시도
        </button>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="login-screen">
        <h2>로그인이 필요합니다</h2>
        <button onClick={() => {/* 로그인 로직 */}}>
          로그인하기
        </button>
      </div>
    );
  }

  // 2. 조건부 렌더링 in JSX
  return (
    <div className="dashboard">
      <header>
        <h1>대시보드</h1>
        <div className="user-info">
          <span>환영합니다, {user.name}님!</span>
          {user.isAdmin && <span className="admin-badge">관리자</span>}
        </div>
      </header>

      <main>
        {/* 3. 삼항 연산자 */}
        {user.notifications.length > 0 ? (
          <div className="notifications">
            <h3>알림 ({user.notifications.length})</h3>
            {user.notifications.map(notification => (
              <div key={notification.id} className="notification">
                {notification.message}
              </div>
            ))}
          </div>
        ) : (
          <div className="no-notifications">
            <p>새로운 알림이 없습니다</p>
          </div>
        )}

        {/* 4. 논리 AND 연산자 */}
        {user.isPremium && (
          <div className="premium-features">
            <h3>프리미엄 기능</h3>
            <PremiumDashboard user={user} />
          </div>
        )}

        {/* 5. IIFE 패턴 (복잡한 조건) */}
        {(() => {
          if (user.role === 'admin') {
            return <AdminPanel />;
          } else if (user.role === 'moderator') {
            return <ModeratorPanel />;
          } else {
            return <UserPanel user={user} />;
          }
        })()}
      </main>
    </div>
  );
};
```

---

## 🎯 실습 프로젝트: 개인 블로그 앱

```tsx
// 📁 src/types/blog.ts
export interface Post {
  id: number;
  title: string;
  content: string;
  author: string;
  createdAt: Date;
  tags: string[];
  isPublished: boolean;
}

// 📁 src/components/BlogApp.tsx
import { useState } from 'react';
import { Post } from '../types/blog';

const BlogApp: React.FC = () => {
  const [posts, setPosts] = useState<Post[]>([
    {
      id: 1,
      title: 'React 학습 일기',
      content: 'React를 배우기 시작했습니다...',
      author: 'Andrew',
      createdAt: new Date('2024-01-01'),
      tags: ['React', '학습'],
      isPublished: true
    }
  ]);
  
  const [currentView, setCurrentView] = useState<'list' | 'create' | 'edit'>('list');
  const [editingPost, setEditingPost] = useState<Post | null>(null);

  const createPost = (newPost: Omit<Post, 'id' | 'createdAt'>) => {
    const post: Post = {
      ...newPost,
      id: Date.now(),
      createdAt: new Date()
    };
    setPosts([post, ...posts]);
    setCurrentView('list');
  };

  const updatePost = (updatedPost: Post) => {
    setPosts(posts.map(post => 
      post.id === updatedPost.id ? updatedPost : post
    ));
    setCurrentView('list');
    setEditingPost(null);
  };

  const deletePost = (id: number) => {
    if (confirm('정말 삭제하시겠습니까?')) {
      setPosts(posts.filter(post => post.id !== id));
    }
  };

  const publishedPosts = posts.filter(post => post.isPublished);

  return (
    <div className="blog-app">
      <header className="blog-header">
        <h1>내 블로그</h1>
        <nav>
          <button 
            onClick={() => setCurrentView('list')}
            className={currentView === 'list' ? 'active' : ''}
          >
            포스트 목록
          </button>
          <button 
            onClick={() => setCurrentView('create')}
            className={currentView === 'create' ? 'active' : ''}
          >
            새 포스트
          </button>
        </nav>
      </header>

      <main>
        {currentView === 'list' && (
          <PostList 
            posts={publishedPosts}
            onEdit={(post) => {
              setEditingPost(post);
              setCurrentView('edit');
            }}
            onDelete={deletePost}
          />
        )}
        
        {currentView === 'create' && (
          <PostForm onSubmit={createPost} onCancel={() => setCurrentView('list')} />
        )}
        
        {currentView === 'edit' && editingPost && (
          <PostForm 
            post={editingPost}
            onSubmit={updatePost}
            onCancel={() => {
              setCurrentView('list');
              setEditingPost(null);
            }}
          />
        )}
      </main>
    </div>
  );
};

// 컴포넌트들을 더 작성해보세요!
```

---

## ✅ 체크포인트

이 강의를 완료했다면 다음을 할 수 있어야 합니다:

- [ ] CSR, SSR, SSG 렌더링 방식의 차이점과 사용 시기 설명
- [ ] JSX 문법 완전 활용
- [ ] Props와 State의 차이점 이해하고 적절히 사용
- [ ] 타입 안전한 이벤트 핸들링
- [ ] 다양한 조건부 렌더링 패턴 활용
- [ ] 컴포넌트 기반으로 UI 설계

## 💡 핵심 정리

1. **React = 선언적 UI 라이브러리**
   - "어떻게"가 아닌 "무엇을" 그릴지 정의
   - Virtual DOM으로 효율적 업데이트

2. **렌더링 전략 선택 기준**
   - SEO 중요하면 → SSR/SSG
   - 실시간 데이터 중요하면 → CSR
   - 정적 콘텐츠면 → SSG

3. **Props는 아래로, Events는 위로**
   - 데이터는 부모에서 자식으로
   - 이벤트는 자식에서 부모로

## 🔗 다음 강의 미리보기

Phase 2에서는 **React Hooks & 현대적 상태관리**를 배워보겠습니다:
- useState, useEffect 마스터
- Zustand로 전역 상태 관리
- Custom Hooks 만들기

React 기초를 탄탄히 다졌으니 이제 Hook의 세계로 들어가봅시다! 🚀