# 1강: 최신 JavaScript 마스터

## 🎯 학습 목표
- ES6+ 문법을 완벽히 이해하고 활용할 수 있다
- 모던 JavaScript의 장점과 필요성을 설명할 수 있다
- 비동기 프로그래밍 패턴을 익힐 수 있다

---

## 🤔 왜 최신 JavaScript를 배워야 할까?

### 기존 JavaScript의 문제점
```javascript
// 😢 예전 방식 - 복잡하고 읽기 어려움
function getUserData(id, callback) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', '/api/users/' + id);
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var user = JSON.parse(xhr.responseText);
        callback(null, user);
      } else {
        callback(new Error('User not found'));
      }
    }
  };
  xhr.send();
}
```

### 현대적 JavaScript의 장점
```javascript
// 😍 모던 방식 - 간결하고 직관적
const getUserData = async (id) => {
  try {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    return user;
  } catch (error) {
    throw new Error('User not found');
  }
};
```

**차이점:**
- ✅ 코드가 훨씬 읽기 쉬움
- ✅ 에러 처리가 직관적
- ✅ 콜백 지옥 해결
- ✅ 최신 브라우저 최적화

---

## 📚 핵심 ES6+ 문법

### 1. Arrow Functions (화살표 함수)

**왜 필요할까?**
- `this` 바인딩 문제 해결
- 코드가 더 간결해짐
- 함수형 프로그래밍에 적합

```javascript
// 😢 기존 방식
function add(a, b) {
  return a + b;
}

const numbers = [1, 2, 3];
const doubled = numbers.map(function(num) {
  return num * 2;
});

// 😍 Arrow Function
const add = (a, b) => a + b;

const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2);

// this 바인딩 차이
class Counter {
  constructor() {
    this.count = 0;
  }
  
  // 😢 일반 함수 - this 문제 발생
  startBad() {
    setInterval(function() {
      this.count++; // this가 window를 가리킴!
      console.log(this.count); // NaN
    }, 1000);
  }
  
  // 😍 Arrow Function - this 자동 바인딩
  startGood() {
    setInterval(() => {
      this.count++; // this가 Counter 인스턴스를 가리킴
      console.log(this.count); // 1, 2, 3...
    }, 1000);
  }
}
```

### 2. Destructuring (구조 분해 할당)

**왜 유용할까?**
- 객체/배열에서 필요한 값만 추출
- React Props 사용할 때 필수
- 코드가 더 깔끔해짐

```javascript
// 😢 기존 방식
const user = {
  name: 'Andrew',
  age: 25,
  email: 'andrew@example.com',
  address: {
    city: 'Seoul',
    country: 'Korea'
  }
};

const name = user.name;
const age = user.age;
const city = user.address.city;

// 😍 Destructuring
const { name, age } = user;
const { address: { city } } = user; // 중첩 구조 분해

// 배열 destructuring
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

// React에서 자주 사용되는 패턴
// 😍 Props destructuring
function UserCard({ name, age, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
    </div>
  );
}

// 😍 useState destructuring
const [count, setCount] = useState(0);
```

### 3. Template Literals (템플릿 리터럴)

**왜 좋을까?**
- 문자열 연결이 직관적
- 여러 줄 문자열 지원
- HTML 템플릿 작성에 유용

```javascript
// 😢 기존 방식
const name = 'Andrew';
const age = 25;
const message = 'Hello, my name is ' + name + ' and I am ' + age + ' years old.';

// 😍 Template Literals
const message = `Hello, my name is ${name} and I am ${age} years old.`;

// 여러 줄 지원
const htmlTemplate = `
  <div class="user-card">
    <h2>${name}</h2>
    <p>Age: ${age}</p>
    <p>Status: ${age >= 18 ? 'Adult' : 'Minor'}</p>
  </div>
`;

// 함수 호출도 가능
const calculation = `2 + 3 = ${2 + 3}`;
const formatted = `Today is ${new Date().toLocaleDateString()}`;
```

### 4. Modules (import/export)

**왜 중요할까?**
- 코드를 모듈로 분리해서 관리
- 재사용성 증가
- React 컴포넌트 분리 필수

```javascript
// 📁 utils.js
// 😍 Named Export
export const formatCurrency = (amount) => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW'
  }).format(amount);
};

export const formatDate = (date) => {
  return date.toLocaleDateString('ko-KR');
};

// 😍 Default Export
const API_BASE_URL = 'https://api.example.com';

export default API_BASE_URL;

// 📁 main.js
// 😍 Import 방식
import API_BASE_URL, { formatCurrency, formatDate } from './utils.js';

// 사용
console.log(formatCurrency(10000)); // ₩10,000
console.log(formatDate(new Date())); // 2024. 12. 31.

// React에서 자주 사용되는 패턴
// 📁 Button.jsx
import React from 'react';

const Button = ({ children, onClick, variant = 'primary' }) => {
  return (
    <button 
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
};

export default Button;

// 📁 App.jsx
import Button from './components/Button';

function App() {
  return (
    <div>
      <Button onClick={() => alert('Clicked!')}>
        Click me!
      </Button>
    </div>
  );
}
```

---

## 🔄 비동기 프로그래밍

### Promise와 async/await

**왜 필요할까?**
- API 호출 시 필수
- 사용자 경험 개선
- React에서 데이터 페칭 필수 기능

```javascript
// 😢 콜백 지옥
function getUserPosts(userId, callback) {
  getUser(userId, (user) => {
    if (user) {
      getPosts(user.id, (posts) => {
        if (posts) {
          getComments(posts[0].id, (comments) => {
            callback({ user, posts, comments });
          });
        }
      });
    }
  });
}

// 😍 Promise 체이닝
function getUserPosts(userId) {
  return getUser(userId)
    .then(user => getPosts(user.id))
    .then(posts => getComments(posts[0].id))
    .then(comments => ({ user, posts, comments }))
    .catch(error => console.error(error));
}

// 😍 async/await (가장 현대적인 방식)
async function getUserPosts(userId) {
  try {
    const user = await getUser(userId);
    const posts = await getPosts(user.id);
    const comments = await getComments(posts[0].id);
    
    return { user, posts, comments };
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error;
  }
}

// React에서 실제 사용 예시
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [userData, setUserData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUserData = async () => {
      try {
        setLoading(true);
        const data = await getUserPosts(userId);
        setUserData(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchUserData();
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h1>{userData.user.name}</h1>
      <p>Posts: {userData.posts.length}</p>
    </div>
  );
}
```

---

## 🛠️ 배열 메서드 활용

### map, filter, reduce

**React에서 왜 중요할까?**
- 리스트 렌더링의 핵심
- 데이터 변환의 기본
- 함수형 프로그래밍 패러다임

```javascript
const users = [
  { id: 1, name: 'Andrew', age: 25, active: true },
  { id: 2, name: 'Bob', age: 30, active: false },
  { id: 3, name: 'Charlie', age: 35, active: true }
];

// 😍 map - 데이터 변환
const userNames = users.map(user => user.name);
// ['Andrew', 'Bob', 'Charlie']

// React에서 리스트 렌더링
function UserList({ users }) {
  return (
    <div>
      {users.map(user => (
        <div key={user.id} className="user-card">
          <h3>{user.name}</h3>
          <p>Age: {user.age}</p>
          <p>Status: {user.active ? 'Active' : 'Inactive'}</p>
        </div>
      ))}
    </div>
  );
}

// 😍 filter - 조건에 맞는 데이터만 추출
const activeUsers = users.filter(user => user.active);
const youngUsers = users.filter(user => user.age < 30);

// React에서 필터링된 리스트 렌더링
function ActiveUserList({ users }) {
  const activeUsers = users.filter(user => user.active);
  
  return (
    <div>
      <h2>Active Users ({activeUsers.length})</h2>
      {activeUsers.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// 😍 reduce - 데이터 집계
const totalAge = users.reduce((sum, user) => sum + user.age, 0);
const usersByAge = users.reduce((groups, user) => {
  const ageGroup = user.age >= 30 ? '30+' : '20s';
  groups[ageGroup] = groups[ageGroup] || [];
  groups[ageGroup].push(user);
  return groups;
}, {});

// 실제 React 프로젝트에서 사용 예시
function ShoppingCart({ items }) {
  const totalPrice = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);

  return (
    <div className="shopping-cart">
      <h2>Shopping Cart ({totalItems} items)</h2>
      {items.map(item => (
        <div key={item.id} className="cart-item">
          <span>{item.name}</span>
          <span>{item.quantity} × {formatCurrency(item.price)}</span>
        </div>
      ))}
      <div className="cart-total">
        Total: {formatCurrency(totalPrice)}
      </div>
    </div>
  );
}
```

---

## 🎯 실습 과제

### 과제 1: 사용자 데이터 처리
다음 데이터를 활용해서 ES6+ 문법을 연습해보세요:

```javascript
const users = [
  { id: 1, name: 'Andrew Kim', age: 25, city: 'Seoul', hobbies: ['coding', 'gaming'] },
  { id: 2, name: 'Bob Lee', age: 30, city: 'Busan', hobbies: ['reading', 'traveling'] },
  { id: 3, name: 'Charlie Park', age: 28, city: 'Seoul', hobbies: ['music', 'coding'] }
];

// TODO: 다음 함수들을 ES6+ 문법으로 구현해보세요

// 1. 서울에 사는 사용자만 필터링하는 함수
const getSeoulUsers = (users) => {
  // 여기에 구현
};

// 2. 사용자 이름과 나이만 추출하는 함수  
const getUserSummary = (users) => {
  // 여기에 구현 - { name: 'Andrew Kim', age: 25 } 형태로
};

// 3. 평균 나이를 계산하는 함수
const getAverageAge = (users) => {
  // 여기에 구현
};

// 4. 취미별 사용자 수를 계산하는 함수
const getHobbyCounts = (users) => {
  // 여기에 구현 - { coding: 2, gaming: 1, ... } 형태로
};
```

### 과제 2: 비동기 데이터 페칭
```javascript
// 가상의 API 함수들
const fetchUser = (id) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: `User ${id}`, email: `user${id}@example.com` });
    }, 1000);
  });
};

const fetchUserPosts = (userId) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Post 1', userId },
        { id: 2, title: 'Post 2', userId }
      ]);
    }, 800);
  });
};

// TODO: async/await를 사용해서 사용자와 게시글을 함께 가져오는 함수 작성
const getUserWithPosts = async (userId) => {
  // 여기에 구현
  // 결과: { user: {...}, posts: [...] }
};

// TODO: 여러 사용자의 데이터를 동시에 가져오는 함수 작성
const getMultipleUsers = async (userIds) => {
  // 힌트: Promise.all() 사용
};
```

---

## ✅ 체크포인트

이 강의를 완료했다면 다음을 할 수 있어야 합니다:

- [ ] Arrow Function과 일반 함수의 차이점 설명
- [ ] Destructuring으로 객체/배열에서 값 추출
- [ ] Template Literals로 문자열 만들기
- [ ] import/export로 모듈 시스템 사용
- [ ] async/await로 비동기 코드 작성
- [ ] map, filter, reduce로 배열 처리

## 🔗 다음 강의 미리보기

다음 강의에서는 **현대적 개발 환경 구축**을 배워보겠습니다:
- Vite 프로젝트 생성
- TypeScript 설정
- ESLint + Prettier 설정

최신 JavaScript 문법을 익혔다면, 이제 이를 활용할 수 있는 개발 환경을 만들어봅시다! 🚀